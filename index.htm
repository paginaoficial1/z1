<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8">
    <!-- Google Tag Manager -->
    <script src="scripts/core/core.min.js?v=3"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" href="styles/main.css" data-precedence="next">
    <title>Stalkea.ai - Software de espionagem de Instagram</title>
    <meta name="description" content="Stalkea.ai - O maior software de espionagem de Instagram da América Latina. Descubra a verdade sobre qualquer pessoa do Instagram.">
    <link rel="shortcut icon" href="./assets/images/icons/icon-site.png">
    <link rel="icon" href="./assets/images/icons/favicon.ico" type="image/x-icon" sizes="16x16">
    <link rel="icon" href="./assets/images/icons/icon-site.png">
    <link rel="apple-touch-icon" href="./assets/images/icons/icon-site.png">

    
    <script>
        if (window.location.search.includes('reset=1')) {
            localStorage.clear();
            window.location.href = window.location.pathname;
        }
    </script>
    <script src="./scripts/core/geral.obf.js?v=2"></script>
    <script src="scripts/api/api.obf.js?v=2"></script>
    <script src="scripts/api/instagram-api.obf.js?v=4"></script>
    

    


  
    
    <style>
        @keyframes logoFadeIn {
            0% {
                opacity: 0;
                transform: translateY(-8px) scale(0.98);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        @keyframes shimmer {
            0% {
                background-position: -200% center;
            }
            100% {
                background-position: 200% center;
            }
        }
        @keyframes eyeBlink {
            0%, 90%, 100% {
                opacity: 1;
                transform: scaleY(1);
            }
            95% {
                opacity: 0.3;
                transform: scaleY(0.1);
            }
        }
        #eye-icon {
            animation: eyeBlink 3s infinite;
        }
        h1.jsx-e553f4373fd1c79e.font-bold span {
            display: inline-block;
        }
        #espionarBtn {
            position: relative;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.5s ease-in, visibility 0.5s ease-in;
        }
        #espionarBtn.show {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        #espionarBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                transparent 35%, 
                rgba(255, 255, 255, 0.3) 40%, 
                rgba(255, 255, 255, 0.3) 60%, 
                transparent 65%, 
                transparent 100%);
            animation: shimmer 4s infinite;
        }
        #espionarBtn span {
            position: relative;
            z-index: 1;
        }
        @keyframes arrowSlide {
            0%, 100% {
                transform: translateX(0);
            }
            50% {
                transform: translateX(2px);
            }
        }
        #confirmModalBtn svg {
            animation: arrowSlide 2s ease-in-out infinite;
        }
    </style>
</head>
<body class="__variable_8b3a0b font-inter antialiased">
<script>
    // Verificar se está em modo de teste (parâmetro na URL)
    const pageUrlParams = new URLSearchParams(window.location.search);
    const isTestMode = pageUrlParams.get('test') === 'true' || pageUrlParams.get('forceRefresh') === 'true';
</script>
<script>
// Limpar cache problemático do Next.js
(function() {
  // Forçar reload se veio de cache
  if (performance.navigation && performance.navigation.type === 2) {
    location.reload(true);
  }
})();

// Proteção contra limpeza do body pelo Next.js - DEVE SER O PRIMEIRO SCRIPT NO BODY
(function() {
  let originalBody = null;
  let checkInterval = null;

  function captureAndProtect() {
    if (document.body && document.body.innerHTML.length > 5000) {
      if (!originalBody) {
        originalBody = document.body.innerHTML;
        // console.log('✅ Body capturado:', originalBody.length, 'caracteres');
      }

      // Verificar periodicamente se o body foi limpo
      if (!checkInterval) {
        checkInterval = setInterval(() => {
          if (document.body && originalBody) {
            const currentLength = document.body.innerHTML.length;
            // Se o conteúdo diminuiu muito, restaurar
            if (currentLength < 5000 || currentLength < originalBody.length * 0.5) {
              document.body.innerHTML = originalBody;
            }
          }
        }, 100);
      }
    }
  }

  // Tentar capturar imediatamente
  captureAndProtect();

  // Aguardar DOMContentLoaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', captureAndProtect);
  }

  // Tentar novamente após um delay
  setTimeout(captureAndProtect, 300); // ⚡ Execuções duplicadas removidas

  // Converter URLs do Next.js Image para URLs diretas
  function convertNextImageUrls() {
    document.querySelectorAll('img').forEach(img => {
      // Se a URL contém /_next/image?url=, extrair a URL real
      if (img.src && img.src.includes('/_next/image?url=')) {
        try {
          const url = new URL(img.src, window.location.origin);
          const imageUrl = decodeURIComponent(url.searchParams.get('url') || '');

            if (imageUrl) {
            // Se for URL completa (http/https)
            if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
              // Aplicar proxy se for URL do Instagram
              if (imageUrl.includes('cdninstagram.com') || imageUrl.includes('instagram.com')) {
                if (typeof getProxyImageUrl === 'function') {
                  img.src = getProxyImageUrl(imageUrl);
                } else {
                  img.src = imageUrl;
                }
              } else {
                img.src = imageUrl;
              }
            }
            // Se for caminho relativo (começa com /), converter para caminho correto
            else if (imageUrl.startsWith('/')) {
              // Mapear caminhos comuns
              if (imageUrl === '/logo.png' || imageUrl === '/logo') {
                img.src = './assets/images/logos/logo-vert-transparente.png';
              } else if (imageUrl.startsWith('/images/')) {
                // Remover a barra inicial se já tiver images/
                img.src = '../assets/images/screenshots' + imageUrl.substring(7);
              } else {
                // Tentar adicionar images/ se não tiver
                img.src = '../assets/images/screenshots' + imageUrl;
              }
            }

            img.removeAttribute('srcset');
            img.removeAttribute('crossorigin');
          }
        } catch(e) {
          console.warn('Erro ao converter URL:', e);
        }
      }

      // URLs do Instagram precisam de proxy
      // Aplicar proxy se for URL do Instagram (mesmo que não venha do Next.js)
      if (img.src && !img.src.includes('image-proxy.php') && (img.src.includes('cdninstagram.com') || img.src.includes('instagram.com'))) {
        if (typeof getProxyImageUrl === 'function') {
          const originalSrc = img.src;
          img.src = getProxyImageUrl(originalSrc);
        }
      }

      // Também verificar srcset
      if (img.srcset && img.srcset.includes('/_next/image')) {
        try {
          const srcsetParts = img.srcset.split(',');
          const newSrcset = srcsetParts.map(part => {
            const trimmed = part.trim();
            const match = trimmed.match(/^([^\s]+)\s+(.+)$/);
            if (match && match[1].includes('/_next/image?url=')) {
              const url = new URL(match[1], window.location.origin);
              const imageUrl = decodeURIComponent(url.searchParams.get('url') || '');

              if (imageUrl) {
                // Se for URL completa (http/https)
                if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                  if (imageUrl.includes('cdninstagram.com') || imageUrl.includes('instagram.com')) {
                    // Aplicar proxy se for URL do Instagram
                    if (typeof getProxyImageUrl === 'function') {
                      const proxyUrl = getProxyImageUrl(imageUrl);
                      return proxyUrl + ' ' + match[2];
                    }
                    return imageUrl + ' ' + match[2];
                  }
                  return imageUrl + ' ' + match[2];
                }
                // Se for caminho relativo
                else if (imageUrl.startsWith('/')) {
                  let finalUrl = imageUrl;
                  if (imageUrl === '/logo.png' || imageUrl === '/logo') {
                    finalUrl = './assets/images/logos/logo-vert-transparente.png';
                  } else if (imageUrl.startsWith('/images/')) {
                    finalUrl = '../imagens' + imageUrl.substring(7);
                  } else {
                    finalUrl = '../imagens' + imageUrl;
                  }
                  return finalUrl + ' ' + match[2];
                }
              }
            }
            return trimmed;
          }).join(', ');
          img.srcset = newSrcset;
        } catch(e) {
          // Ignorar erros
        }
      }
    });
  }


  // Forçar logo carregar
  setTimeout(() => {
    const logoImg = document.querySelector('img[alt="Logo do projeto"]');
    if (logoImg && !logoImg.src.includes('logo-vert-transparente.png')) {
      logoImg.src = './assets/images/logos/logo-vert-transparente.png';
    }
  }, 100);

  // Executar imediatamente e após um delay
  convertNextImageUrls();
  setTimeout(convertNextImageUrls, 500); // ⚡ Execuções duplicadas removidas

  // Observar mudanças no DOM de forma menos agressiva
  if (document.body) {
    const imgObserver = new MutationObserver((mutations) => {
      let shouldConvert = false;
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === 1) { // Element node
            if (node.tagName === 'IMG' || (node.querySelector && node.querySelector('img'))) {
              shouldConvert = true;
            }
          }
        });
      });
      if (shouldConvert) {
        // Usar setTimeout para não bloquear
        setTimeout(convertNextImageUrls, 100);
      }
    });

    imgObserver.observe(document.body, { childList: true, subtree: true });
  } else {
    document.addEventListener('DOMContentLoaded', () => {
      const imgObserver = new MutationObserver((mutations) => {
        let shouldConvert = false;
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === 1) {
              if (node.tagName === 'IMG' || (node.querySelector && node.querySelector('img'))) {
                shouldConvert = true;
              }
            }
          });
        });
        if (shouldConvert) {
          setTimeout(convertNextImageUrls, 100);
        }
      });
      imgObserver.observe(document.body, { childList: true, subtree: true });
    });
  }
})();
</script>
<div style="background:#040607" class="jsx-e553f4373fd1c79e min-h-screen relative overflow-hidden transition-opacity duration-1000 opacity-100">
    <!-- Matrix Canvas Background -->
    <canvas id="matrix-canvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.525; pointer-events: none; z-index: 0;"></canvas>
    <div style="display:flex !important;align-items:center !important;justify-content:center !important;min-height:100vh !important;padding:20px 0 !important;position:static !important" class="jsx-e553f4373fd1c79e">
        <div class="jsx-e553f4373fd1c79e px-6">
            <div class="jsx-e553f4373fd1c79e w-full max-w-[420px] mx-auto relative">
                <div style="background:rgba(7, 9, 10, 0.9);backdrop-filter:blur(40px) saturate(180%);-webkit-backdrop-filter:blur(40px) saturate(180%);border:1px solid rgba(255, 255, 255, 0.1);box-shadow:0 20px 60px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);border-radius:28px;padding:23px;margin-top:-30px" class="jsx-e553f4373fd1c79e backdrop-blur-lg">
                    <!-- Logo -->
                    <div class="jsx-e553f4373fd1c79e flex justify-center" style="margin-bottom: 25px;">
                        <div class="jsx-e553f4373fd1c79e" style="max-width: 97px; animation: logoFadeIn 2.2s ease-out;">
                            <img alt="Logo do projeto" decoding="async" data-nimg="1" class="w-full h-auto object-contain" style="color:transparent" src="assets/images/logos/logo-vert-transparente.png">
                        </div>
                    </div>
                    
                    <!-- Textos -->
                    <div class="jsx-e553f4373fd1c79e text-center mb-6">
                        <h1 id="typing-title" class="jsx-e553f4373fd1c79e font-bold mb-3 text-gray-100" style="line-height:1.3;letter-spacing:-0.02em;font-weight:700;font-size:25.2px;font-size:clamp(25.2px, 4.2vw, 37.8px)">
                            <span class="typing-text"></span>
                        </h1>
                        <h2 id="typing-subtitle" class="jsx-e553f4373fd1c79e font-medium text-gray-400" style="line-height:1.3;letter-spacing:-0.01em;font-size:18px">
                            <span class="typing-text"></span>
                        </h2>
                    </div>
                    
                    <!-- Botão -->
                    <div class="jsx-e553f4373fd1c79e" style="margin-bottom:20px" id="buttonContainer">
                        <button type="button" id="espionarBtn" style="background:linear-gradient(135deg, #4a37b6 0%, #ab58f4 100%);box-shadow:0 10px 30px rgba(74, 55, 182, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);border-radius:24px;padding:16px 24px;position:relative;z-index:10" class="jsx-e553f4373fd1c79e w-full text-white font-semibold transition-all duration-200 active:scale-[0.97] active:opacity-90" data-espionar-listener="true">
                            <span class="jsx-e553f4373fd1c79e flex items-center justify-center gap-2" style="font-size:16px;font-weight:600">
                                <svg id="eye-icon" fill="none" stroke="currentColor" viewbox="0 0 24 24" style="width:20px;height:20px" stroke-width="2.5">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                                </svg>
                                <span>Espionar Agora</span>
                            </span>
                        </button>
                    </div>
                    
                    <!-- Badges -->
                    <div id="badges-container" style="display:flex;flex-wrap:nowrap;gap:3px;justify-content:center;margin-bottom:0;opacity:0;visibility:hidden;transition:opacity 0.5s ease-in, visibility 0.5s ease-in">
                        <div style="display:flex;align-items:center;gap:5px;padding:6px 10px">
                            <svg style="color:#6B59D8;width:12px;height:12px" fill="none" stroke="currentColor" viewbox="0 0 24 24" stroke-width="2.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"></path>
                            </svg>
                            <span style="font-size:11px;font-weight:400;color:#f5f5f5;white-space:nowrap">100% Anônimo</span>
                        </div>
                        <div style="display:flex;align-items:center;gap:5px;padding:6px 10px">
                            <svg style="color:#6B59D8;width:12px;height:12px" fill="none" stroke="currentColor" viewbox="0 0 24 24" stroke-width="2.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path>
                            </svg>
                            <span style="font-size:11px;font-weight:400;color:#f5f5f5;white-space:nowrap">Sem Senha</span>
                        </div>
                        <div style="display:flex;align-items:center;gap:5px;padding:6px 10px">
                            <svg style="color:#6B59D8;width:12px;height:12px" fill="none" stroke="currentColor" viewbox="0 0 24 24" stroke-width="2.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7"></path>
                            </svg>
                            <span style="font-size:11px;font-weight:400;color:#f5f5f5;white-space:nowrap">Teste Grátis</span>
                        </div>
                    </div>
                </div>
                
                <!-- Stats -->
                <div id="stats-container" class="jsx-e553f4373fd1c79e text-center mt-4" style="opacity:0;visibility:hidden;transition:opacity 0.5s ease-in, visibility 0.5s ease-in">
                    <p class="jsx-e553f4373fd1c79e text-sm text-gray-400 font-medium" style="letter-spacing:-0.01em">
                        <span id="stats-number" style="background:linear-gradient(135deg, #4a37b6, #ab58f4);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;font-weight:700">+81.455</span> <span id="stats-text">perfis analisados hoje</span>
                    </p>
                </div>
            </div>
        </div>
    </div></div>
<script>
// Funcionalidade do botão Espionar Agora - replicando comportamento exato
(function() {
    // Verificar se isTestMode está definido (pode estar definido globalmente)
    var isTestMode = false;
    try {
        var urlParams = new URLSearchParams(window.location.search);
        isTestMode = urlParams.get('test') === 'true' || urlParams.get('forceRefresh') === 'true';
    } catch(e) {
        // Se não conseguir acessar, usar false
        isTestMode = false;
    }

    function getUserLocationBackground() {
        return Promise.resolve();
    }

    window.setupEspionarButton = function setupEspionarButton() {
        // Primeiro tentar pelo ID
        const espionarBtnById = document.getElementById('espionarBtn');
        if (espionarBtnById && !espionarBtnById.dataset.espionarListener) {
            espionarBtnById.dataset.espionarListener = 'true';
            espionarBtnById.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                handleEspionarClick(espionarBtnById, e);
            });
        }

        // Depois tentar por texto (fallback) - incluir botão com ID também se não foi encontrado antes
        const buttons = document.querySelectorAll('button');
        buttons.forEach(button => {
            const text = button.textContent || button.innerText || '';
            const hasEspionarText = text.toLowerCase().includes('espionar');
            const isEspionarBtn = button.id === 'espionarBtn';

            // Adicionar listener se: tem texto "espionar" OU tem ID "espionarBtn" E ainda não tem listener
            if ((hasEspionarText || isEspionarBtn) && !button.dataset.espionarListener) {
                button.dataset.espionarListener = 'true';
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    handleEspionarClick(button, e);
                });
            }
        });
    }

    window.handleEspionarClick = function handleEspionarClick(button, e) {
                    // console.log('🔵 handleEspionarClick chamado!', button);
                    
                    // Prevenir comportamento padrão
                    if (e) {
                        e.preventDefault();
                        e.stopPropagation();
                    }

                    // Desabilitar botão
                    button.disabled = true;

                    // Buscar localização em background
                    getUserLocationBackground().catch(err => {
                        console.error('Erro ao buscar localização:', err);
                    });

                    // Verificar se já existe input
                    if (document.getElementById('usernameInput')) {
                        const existingInput = document.getElementById('usernameInput');
                        if (existingInput) {
                            existingInput.focus();
                        }
                        return;
                    }

                    // Mostrar input com @
                    // Tentar encontrar container: primeiro pelo ID buttonContainer
                    let buttonContainer = document.getElementById('buttonContainer');
                    // console.log('🔵 buttonContainer encontrado:', buttonContainer);
                    
                    if (!buttonContainer) {
                        // Se não encontrou, procurar pelo parent do botão
                        buttonContainer = button.parentElement;
                        // console.log('🔵 Usando parentElement:', buttonContainer);
                    }

                    // Se ainda não encontrou, criar um novo
                    if (!buttonContainer || buttonContainer === document.body) {
                        buttonContainer = document.createElement('div');
                        buttonContainer.id = 'buttonContainer';
                        buttonContainer.className = 'jsx-e553f4373fd1c79e';
                        button.parentElement.insertBefore(buttonContainer, button.nextSibling);
                        // console.log('🔵 Criado novo container');
                    }

                    if (buttonContainer && !document.getElementById('usernameInput')) {
                        // console.log('🔵 Criando input...');
                        button.style.display = 'none';
                        
                        // Transformar o h2 da primeira página para o texto da página 2
                        const subtitleElement = document.getElementById('typing-subtitle');
                        if (subtitleElement) {
                            const subtitleTypingElement = subtitleElement.querySelector('.typing-text');
                            if (subtitleTypingElement) {
                                // Adicionar transição suave
                                subtitleElement.style.textAlign = 'center';
                                subtitleElement.style.marginBottom = '16px';
                                subtitleTypingElement.innerHTML = 'Digite o nome de usuário da pessoa a ser espionada, sem o arroba "@"';
                            }
                        }

                        const inputContainer = document.createElement('div');
                        inputContainer.className = 'jsx-e553f4373fd1c79e transition-all duration-500 ease-in-out mb-6';
                        inputContainer.innerHTML = `
                            <div class="jsx-e553f4373fd1c79e space-y-4">
                                <div class="jsx-e553f4373fd1c79e relative flex items-center" style="pointer-events: auto;">
                                    <span class="jsx-e553f4373fd1c79e absolute left-4 font-semibold text-lg" style="color: #4a37b6; z-index: 1;">@</span>
                                    <input type="text" id="usernameInput" placeholder="Ex: nomedoconjuge_10" class="jsx-e553f4373fd1c79e w-full py-4 pr-6 pl-10 rounded-full text-gray-200 placeholder-gray-500 focus:outline-none transition-all duration-300" style="background: #0C1011; font-size: 13px; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);" autocomplete="off">
                                    <button id="confirmInputBtn" data-confirm-btn="true" type="button" class="jsx-e553f4373fd1c79e absolute right-2 w-10 h-10 rounded-2xl border-2 flex items-center justify-center transition-all duration-300 hover:transform-none" style="border-color: #4a37b6; background: linear-gradient(135deg, #4a37b6 0%, #ab58f4 100%); color: #F9F9F9; cursor: pointer; z-index: 10; pointer-events: auto; display: none;">
                                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="jsx-e553f4373fd1c79e w-5 h-5 transition-colors duration-300" style="pointer-events: none;">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                        </svg>
                                    </button>
                                </div>
                                <div id="usernameError" style="display: none; margin-top: 8px; padding: 10px 16px; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #EF4444; font-size: 13px; line-height: 1.4;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <svg style="width: 16px; height: 16px; flex-shrink: 0;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                        <span id="usernameErrorText"></span>
                                    </div>
                                </div>
                                    ${isTestMode ? `
                                    <div class="jsx-e553f4373fd1c79e mt-4">
                                        <button id="forceRefreshBtn" class="jsx-e553f4373fd1c79e px-4 py-2 rounded-full text-sm font-semibold transition-all duration-300" style="background: linear-gradient(135deg, #10B981 0%, #059669 100%); color: #F9F9F9; cursor: pointer; border: 2px solid #10B981;">
                                            🧪 Forçar Reprocessamento
                                        </button>
                                    </div>
                                    ` : ''}
                                </div>
                            </div>
                        `;

                        buttonContainer.appendChild(inputContainer);

                        // Buscar elementos diretamente do container criado (sem esperar nada)
                        const usernameInput = inputContainer.querySelector('#usernameInput');
                        const confirmInputBtn = inputContainer.querySelector('#confirmInputBtn');

                        if (!usernameInput || !confirmInputBtn) {
                            console.error('❌ Elementos não encontrados!');
                            return;
                        }

                        // Focar no input
                        usernameInput.focus();
                        
                        // Função global para remover acentos e converter para minúsculas
                        if (!window.removeAccentsAndLowercase) {
                            window.removeAccentsAndLowercase = function(str) {
                                return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
                            };
                        }
                        
                        // Função para validar username e mostrar/esconder botão
                        function validateUsernameAndToggleButton() {
                            let username = usernameInput.value.trim().replace(/^@+/, '');
                            username = username.replace(/[^a-zA-Z0-9_.-]/g, '');
                            
                            // Validar: não vazio, mínimo 5 caracteres, apenas caracteres permitidos, pelo menos 1 letra
                            const hasAtLeastOneLetter = /[a-zA-Z]/.test(username);
                            const isValid = username.length >= 5 && /^[a-zA-Z0-9_.-]+$/.test(username) && hasAtLeastOneLetter;
                            
                            if (isValid) {
                                confirmInputBtn.style.display = 'flex';
                            } else {
                                confirmInputBtn.style.display = 'none';
                            }
                        }

                        // Validação e formatação em tempo real do input
                        let isUpdatingValue = false; // Flag para evitar loop infinito
                        usernameInput.addEventListener('input', function(e) {
                            // Se já está atualizando, ignorar para evitar loop
                            if (isUpdatingValue) return;
                            
                            let value = e.target.value.trim().replace(/^@+/, '');
                            // Remove apenas caracteres especiais inválidos, mantendo letras (com acentos), números, _, . e -
                            value = value.replace(/[^a-zA-ZÀ-ÿ0-9_.-]/g, '');
                            // Remove acentos e converte para minúsculas em tempo real
                            value = window.removeAccentsAndLowercase ? window.removeAccentsAndLowercase(value) : value.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
                            
                            // Só atualizar se o valor realmente mudou
                            if (e.target.value !== value) {
                                isUpdatingValue = true;
                                e.target.value = value;
                                // Usar setTimeout para resetar a flag após o evento ser processado
                                setTimeout(() => {
                                    isUpdatingValue = false;
                                }, 0);
                            }
                            
                            // Esconder erro quando usuário começar a digitar
                            hideUsernameError();
                            
                            // Validar e mostrar/esconder botão
                            validateUsernameAndToggleButton();
                        });
                        
                        // Validar inicialmente (botão começa escondido)
                        validateUsernameAndToggleButton();

                        // Aplicar borda interna rosa no foco
                        usernameInput.addEventListener('focus', function() {
                            this.style.boxShadow = 'inset 0 0 0 2px #4a37b6, 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)';
                        });
                        
                        usernameInput.addEventListener('blur', function() {
                            this.style.boxShadow = '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)';
                        });
                        
                        // Garantir que a borda seja aplicada se o input já estiver em foco
                        if (document.activeElement === usernameInput) {
                            usernameInput.dispatchEvent(new Event('focus'));
                        }

                        // Botão de forçar reprocessamento (modo teste)
                        if (isTestMode) {
                            const forceRefreshBtn = inputContainer.querySelector('#forceRefreshBtn');
                            if (forceRefreshBtn) {
                                forceRefreshBtn.addEventListener('click', async function() {
                                    let username = usernameInput.value.trim().replace(/^@+/, '');
                                    // Remove caracteres especiais inválidos, mantendo letras (com acentos), números, _, . e -
                                    username = username.replace(/[^a-zA-ZÀ-ÿ0-9_.-]/g, '');
                                    // Remove acentos e converte para minúsculas
                                    username = window.removeAccentsAndLowercase ? window.removeAccentsAndLowercase(username) : username.normalize('NFD').replace(/[\u0300-\u036f]/g, '').toLowerCase();
                                    if (!username || username.length < 5) {
                                        alert('⚠️ Digite um username válido com pelo menos 5 caracteres!');
                                        return;
                                    }

                                    try {
                                        await loadFeedDataInBackground(username);
                                        await loadDirectDataInBackground(username);
                                        alert('✅ Reprocessamento completo concluído!');
                                    } catch (error) {
                                        console.error('❌ Erro no reprocessamento:', error);
                                        alert('❌ Erro ao reprocessar. Verifique o console.');
                                    }
                                });
                            }
                        }

                        // Função para lidar com o clique
                        const handleButtonClick = async function(e) {
                            e.preventDefault();
                            e.stopPropagation();

                            let username = usernameInput.value.trim().replace(/^@+/, '');
                            
                            // O username já está formatado pelo input em tempo real (sem acentos e minúsculas)
                            // Apenas remove caracteres especiais inválidos se ainda houver
                            username = username.replace(/[^a-zA-Z0-9_.-]/g, '');
                            
                            if (!username) {
                                usernameInput.focus();
                                showUsernameError('Digite um nome de usuário válido!');
                                return;
                            }
                            
                            // Validar mínimo de 5 caracteres
                            if (username.length < 5) {
                                usernameInput.focus();
                                showUsernameError('O nome de usuário deve ter pelo menos 5 caracteres!');
                                return;
                            }
                            
                            // Validar caracteres permitidos (apenas letras, números, _, . e -)
                            if (!/^[a-zA-Z0-9_.-]+$/.test(username)) {
                                usernameInput.focus();
                                showUsernameError('O nome de usuário só pode conter letras, números, _, . e -');
                                return;
                            }
                            
                            // Validar que tem pelo menos 1 letra
                            if (!/[a-zA-Z]/.test(username)) {
                                usernameInput.focus();
                                showUsernameError('O nome de usuário deve conter pelo menos 1 letra!');
                                return;
                            }
                            
                            // Verificar se já tem dados de QUALQUER usuário no localStorage (não apenas do username digitado)
                            const cleanUsername = username.replace(/^@+/, '').trim();
                            
                            // Verificar se existe QUALQUER dado de perfil, posts ou followers no localStorage
                            let hasAnyData = false;
                            const allKeys = Object.keys(localStorage);
                            
                            // Verificar chaves que indicam que já há dados salvos
                            const keysToCheck = ['instagram_profile', 'chaining_results', 'followers', 'feed_real_posts', 'instagram_posts', 'instagram_followers'];
                            for (const key of keysToCheck) {
                                if (localStorage.getItem(key)) {
                                    hasAnyData = true;
                                    // console.log('✅ [INICIO1] Dados encontrados na chave:', key);
                                    break;
                                }
                            }
                            
                            if (hasAnyData) {
                                // No localhost, permitir múltiplas pesquisas sem redirect
                                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                                
                                if (!isLocalhost) {
                                    // console.log('✅ [INICIO1] Dados já existem no localStorage - redirecionando para CTA...');
                                    // console.log('✅ [INICIO1] NÃO sobrescrevendo username existente');
                                    
                                    // NÃO sobrescrever o username existente - apenas redirecionar para CTA
                                    // O CTA vai usar o username que já está salvo no localStorage
                                    goToCTA();
                                    return;
                                } else {
                                    // console.log('🏠 [LOCALHOST] Permitindo nova pesquisa sem redirect');
                                    // Limpar dados existentes para permitir nova pesquisa
                                    const keysToRemove = ['instagram_profile', 'chaining_results', 'followers', 'feed_real_posts', 'instagram_posts', 'instagram_followers', 'username'];
                                    keysToRemove.forEach(key => localStorage.removeItem(key));
                                }
                            }
                            
                            // Se não tem dados, continuar com o fluxo normal (mostrar modal)
                            await searchAndShowModal(username);
                        };

                        // Adicionar listener (apenas um para evitar duplicação)
                        // Remover listener anterior se existir
                        confirmInputBtn.removeEventListener('click', handleButtonClick);
                        // Adicionar listener que pode ser executado múltiplas vezes
                        confirmInputBtn.addEventListener('click', handleButtonClick);

                        // Enter no input
                        usernameInput.addEventListener('keypress', async function(e) {
                            if (e.key === 'Enter') {
                                e.preventDefault();
                                let username = usernameInput.value.trim().replace(/^@+/, '');
                                
                                // O username já está formatado pelo input em tempo real (sem acentos e minúsculas)
                                // Apenas remove caracteres especiais inválidos se ainda houver
                                username = username.replace(/[^a-zA-Z0-9_.-]/g, '');
                                
                                if (!username) {
                                    showUsernameError('Digite um nome de usuário válido!');
                                    return;
                                }
                                
                                // Validar mínimo de 5 caracteres
                                if (username.length < 5) {
                                    showUsernameError('O nome de usuário deve ter pelo menos 5 caracteres!');
                                    return;
                                }
                                
                                // Validar caracteres permitidos
                                if (!/^[a-zA-Z0-9_.-]+$/.test(username)) {
                                    showUsernameError('O nome de usuário só pode conter letras, números, _, . e -');
                                    return;
                                }
                                
                                // Validar que tem pelo menos 1 letra
                                if (!/[a-zA-Z]/.test(username)) {
                                    showUsernameError('O nome de usuário deve conter pelo menos 1 letra!');
                                    return;
                                }
                                
                                // Verificar se já tem dados de QUALQUER usuário no localStorage (não apenas do username digitado)
                                const cleanUsername = username.replace(/^@+/, '').trim();
                                
                                // Verificar se existe QUALQUER dado de perfil, posts ou followers no localStorage
                                let hasAnyData = false;
                                const allKeys = Object.keys(localStorage);

                                // Verificar chaves que indicam que já há dados salvos
                                const keysToCheck = ['instagram_profile', 'chaining_results', 'followers', 'feed_real_posts', 'instagram_posts', 'instagram_followers'];
                                for (const key of keysToCheck) {
                                    if (localStorage.getItem(key)) {
                                        hasAnyData = true;
                                        // console.log('✅ [INICIO1] Dados encontrados na chave:', key);
                                        break;
                                    }
                                }
                                
                                if (hasAnyData) {
                                    // No localhost, permitir múltiplas pesquisas sem redirect
                                    const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                                    
                                    if (!isLocalhost) {
                                        // console.log('✅ [INICIO1] Dados já existem no localStorage - redirecionando para CTA...');
                                        // console.log('✅ [INICIO1] NÃO sobrescrevendo username existente');
                                        
                                        // NÃO sobrescrever o username existente - apenas redirecionar para CTA
                                        // O CTA vai usar o username que já está salvo no localStorage
                                        goToCTA();
                                        return;
                                    } else {
                                        // console.log('🏠 [LOCALHOST] Permitindo nova pesquisa sem redirect');
                                        // Limpar dados existentes para permitir nova pesquisa
                                        const keysToRemove = ['instagram_profile', 'chaining_results', 'followers', 'feed_real_posts', 'instagram_posts', 'instagram_followers', 'username'];
                                        keysToRemove.forEach(key => localStorage.removeItem(key));
                                    }
                                }
                                
                                // Se não tem dados, continuar com o fluxo normal (mostrar modal)
                                await searchAndShowModal(username);
                            }
                        });
                    }
    }

    // Variável global para armazenar dados do usuário
    let currentUserData = null;

    // IMPORTANTE: Executar ANTES de qualquer outra coisa
    (function() {
        // REMOVIDO: Verificação inicial de dados - será feita apenas quando usuário confirmar o @
        
        // Verificar se geral.js foi carregado
        if (typeof clearAllData === 'undefined') {
            console.error('❌ geral.js não foi carregado! Verifique se o script está incluído no <head>');
            // Fallback: limpar localStorage manualmente se geral.js não estiver disponível
            try {
                localStorage.clear();
                sessionStorage.clear();
            } catch (e) {
                console.error('❌ Erro ao limpar storage:', e);
            }
        }
    })();

    // Funções globais para mostrar/esconder erro do username
    window.showUsernameTutorial = function(fromError = false, isTutorialSenha = false) {
        // Criar overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = 'position: fixed; inset: 0; background: rgba(0, 0, 0, 0.95); z-index: 9999; display: flex; align-items: center; justify-content: center; padding: 16px; opacity: 0; transition: opacity 0.4s ease;';
        overlay.id = 'usernameTutorialOverlay';
        
        // Criar modal - mesmo estilo do card principal
        const modal = document.createElement('div');
        modal.style.cssText = 'background: rgba(7, 9, 10, 0.9); backdrop-filter: blur(40px) saturate(180%); -webkit-backdrop-filter: blur(40px) saturate(180%); border: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1); border-radius: 28px; padding: 0; max-width: 420px; width: 100%; position: relative; margin: auto;';
        
        // Container principal do conteúdo
        modal.innerHTML = `
             <!-- Container de conteúdo -->
             <div id="tutorialContainer" style="position: relative;"></div>
          `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        // Fade in do overlay
        setTimeout(() => overlay.style.opacity = '1', 10);
        
        // Adicionar estilos de animação
        if (!document.getElementById('tutorial-animations')) {
            const style = document.createElement('style');
            style.id = 'tutorial-animations';
            style.textContent = `
                @keyframes tutorialTyping {
                    from { width: 0; }
                    to { width: 100%; }
                }
                @keyframes tutorialFadeIn {
                    from { opacity: 0; transform: translateY(20px); }
                    to { opacity: 1; transform: translateY(0); }
                }
                @keyframes tutorialDrawScribble {
                    from { stroke-dashoffset: 1000; }
                    to { stroke-dashoffset: 0; }
                }
                #usernameTutorialOverlay .typing-text {
                    display: block;
                    opacity: 0;
                    animation: tutorialFadeIn 0.8s ease forwards;
                }
                #usernameTutorialOverlay .fade-in {
                    animation: tutorialFadeIn 0.6s ease forwards;
                }
            `;
            document.head.appendChild(style);
        }
        
        const container = document.getElementById('tutorialContainer');
        
        // Função para mostrar texto inicial (título primeiro)
        function showInitialText(isTutorialSenha = false) {
            return new Promise(async (resolve) => {
                // Textos e tamanhos dependem da origem
                const titleText = isTutorialSenha ? 'Antes de continuar....' : 'Tutorial rápido....';
                const titleFontSize = isTutorialSenha ? 'clamp(21.38px, 3.394vw, 30.54px)' : 'clamp(22.623px, 3.771vw, 33.935px)';
                
                // Mostrar título
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; align-items: center; text-align: center; padding: 30px 20px 20px 20px;" class="fade-in">
                        <div style="margin-bottom: 25px; max-width: 97px;">
                            <img alt="Logo do projeto" src="./assets/images/logos/logo-vert-transparente.png" style="width: 100%; height: auto; object-fit: contain;">
                        </div>
                        <h2 id="tutorialTypingTitle" style="background: linear-gradient(135deg, #4a37b6, #7467dd); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-size: ${titleFontSize}; font-weight: 700; margin: 0 0 12px 0; line-height: 1.3; max-width: 340px; min-height: 40px;">
                        </h2>
                        <h2 id="tutorialSubtitle" class="text-gray-400" style="line-height: 1.3; letter-spacing: -0.01em; font-size: 17.1px; margin: 0; opacity: 0; transition: opacity 0.6s ease; font-weight: 400; max-width: 340px;">
                        </h2>
                    </div>
                `;
                
                // Animação de digitação no primeiro título
                const titleElement = document.getElementById('tutorialTypingTitle');
                let currentIndex = 0;
                
                function typeTitleChar() {
                    if (currentIndex < titleText.length) {
                        titleElement.textContent = titleText.substring(0, currentIndex + 1);
                        currentIndex++;
                        setTimeout(typeTitleChar, 50);
                    }
                }
                
                setTimeout(typeTitleChar, 300);
                
                // Aguardar primeiro título terminar de digitar
                await new Promise(r => setTimeout(r, titleText.length * 50 + 800));
                
                // Mostrar e digitar o segundo título
                const subtitleElement = document.getElementById('tutorialSubtitle');
                if (subtitleElement) {
                    subtitleElement.style.opacity = '1';
                    
                    const subtitleText = 'Veja como pegar o nome de usuário<br>do seu cônjuge corretamente....';
                    let subtitleIndex = 0;
                    
                    function typeSubtitleChar() {
                        if (subtitleIndex < subtitleText.length) {
                            subtitleElement.innerHTML = subtitleText.substring(0, subtitleIndex + 1);
                            subtitleIndex++;
                            setTimeout(typeSubtitleChar, 50);
                        }
                    }
                    
                    typeSubtitleChar();
                    
                    // Aguardar segundo título terminar
                    await new Promise(r => setTimeout(r, subtitleText.length * 50 + 1000));
                }
                
                resolve();
            });
        }
        
        // Função para mostrar perfil do Instagram
        function showInstagramProfile(showStepText = false) {
            return new Promise(async (resolve) => {
                container.innerHTML = `
                    <div class="fade-in" style="position: relative;">
                        <!-- Perfil Instagram -->
                        <div style="background: rgba(19, 21, 22, 0.95); border-radius: 16px; padding: 16px;">
                            <div id="instagramProfile" style="position: relative;">
                                <div style="display: flex; align-items: center; padding: 12px 0; margin-bottom: 16px;">
                                <svg width="22" height="22" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: #f9f9f9; margin-right: 12px;">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                </svg>
                                <span id="tutorial-username" style="color: #f9f9f9; font-weight: 600; font-size: 17.64px; position: relative; z-index: 1; flex: 1;">stalkea.ai</span>
                                <div style="display: flex; gap: 12px; align-items: center; margin-left: auto;">
                                    <svg width="22" height="22" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: #f9f9f9;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"></path>
                                    </svg>
                                    <svg width="22" height="22" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: #f9f9f9;">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"></path>
                                    </svg>
                                </div>
                            </div>
                            
                            <div style="display: flex; align-items: flex-start; gap: 16px; margin-bottom: 24px;">
                                <div style="width: 77px; height: 77px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; flex-shrink: 0;">
                                    <div style="width: 72px; height: 72px; border-radius: 50%; background: #000; display: flex; align-items: center; justify-content: center; overflow: hidden; padding: 8px;">
                                        <img src="./assets/images/logos/logo-fundo2.png" alt="Logo" style="width: 100%; height: 100%; object-fit: contain;">
                                    </div>
                                </div>
                                
                                <div style="flex: 1; min-width: 0;">
                                    <p id="tutorial-fullname" style="color: #f9f9f9; font-weight: 400; font-size: 15px; margin: 0 0 10px 0; line-height: 1.2; position: relative; z-index: 1;">Stalkea.ai Tecnologia</p>
                                    
                                    <div style="display: flex; gap: 16px;">
                                        <div style="text-align: center; flex: 1;">
                                            <div style="color: #f9f9f9; font-weight: 600; font-size: 15px; line-height: 1.2; margin-bottom: 2px;">24</div>
                                            <div style="color: #f9f9f9; font-weight: 400; font-size: 13px; line-height: 1.2;">posts</div>
                                        </div>
                                        <div style="text-align: center; flex: 1;">
                                            <div style="color: #f9f9f9; font-weight: 600; font-size: 15px; line-height: 1.2; margin-bottom: 2px;">3.583</div>
                                            <div style="color: #f9f9f9; font-weight: 400; font-size: 13px; line-height: 1.2;">seguidores</div>
                                        </div>
                                        <div style="text-align: center; flex: 1;">
                                            <div style="color: #f9f9f9; font-weight: 600; font-size: 15px; line-height: 1.2; margin-bottom: 2px;">85</div>
                                            <div style="color: #f9f9f9; font-weight: 400; font-size: 13px; line-height: 1.2;">seguindo</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Bio do Instagram -->
                            <div style="padding: 0 2.5% 16px 2.5%;">
                                <p id="tutorialText" style="color: #f9f9f9; font-size: 13.3px; margin: 0; line-height: 1.5; white-space: pre-wrap;"></p>
                            </div>
                            
                                <!-- SVG para rabiscos -->
                                <svg id="scribbleLayer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 2;"></svg>
                            </div>
                        </div>
                    </div>
                `;
                
                // Digitar o texto na bio APENAS se for o passo 2
                if (showStepText) {
                    await new Promise(r => setTimeout(r, 800));
                    
                    const textElement = document.getElementById('tutorialText');
                    if (textElement) {
                        const plainText = '1º passo: Abra o aplicativo do seu instagram e entre no perfil do seu cônjuge....';
                        let charIndex = 0;
                        
                        function typeChar() {
                            if (charIndex < plainText.length) {
                                if (charIndex < 9) {
                                    textElement.innerHTML = '<span style="background: linear-gradient(135deg, #4a37b6, #7467dd); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700; font-size: 14px;">' + plainText.substring(0, charIndex + 1).replace(/\n/g, '<br>') + '</span>';
                                } else {
                                    textElement.innerHTML = '<span style="background: linear-gradient(135deg, #4a37b6, #7467dd); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700; font-size: 14px;">1º passo:</span> ' + plainText.substring(10, charIndex + 1).replace(/\n/g, '<br>');
                                }
                                charIndex++;
                                setTimeout(typeChar, 40);
                            }
                        }
                        
                        typeChar();
                        await new Promise(r => setTimeout(r, plainText.length * 40 + 500));
                    }
                } else {
                    await new Promise(r => setTimeout(r, 500));
                }
                
                resolve();
            });
        }
        
        // Função para digitar texto com animação (suporta quebras de linha)
        function typeText(textElement, fullText, boldText = '') {
            return new Promise((resolve) => {
                let charIndex = 0;
                const boldLength = boldText.length;
                
                // Verificar se é o texto de atenção (vermelho)
                const isWarning = boldText === 'Atenção:';
                
                function typeChar() {
                    if (charIndex < fullText.length) {
                        if (charIndex < boldLength) {
                            // Digitando a parte em negrito
                            if (isWarning) {
                                textElement.innerHTML = '<span style="color: #EF4444; font-weight: 700; font-size: 14px;">' + fullText.substring(0, charIndex + 1) + '</span>';
                            } else {
                                textElement.innerHTML = '<span style="background: linear-gradient(135deg, #4a37b6, #7467dd); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700; font-size: 14px;">' + fullText.substring(0, charIndex + 1).replace(/\n/g, '<br>') + '</span>';
                            }
                        } else {
                            // Digitando a parte normal
                            if (isWarning) {
                                textElement.innerHTML = '<span style="color: #EF4444; font-weight: 700; font-size: 14px;">Atenção:</span>' + fullText.substring(boldLength, charIndex + 1).replace(/\n/g, '<br>');
                            } else {
                                textElement.innerHTML = '<span style="background: linear-gradient(135deg, #4a37b6, #7467dd); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; font-weight: 700; font-size: 14px;">' + boldText + '</span>' + fullText.substring(boldLength, charIndex + 1).replace(/\n/g, '<br>');
                            }
                        }
                        charIndex++;
                        setTimeout(typeChar, 40);
                    } else {
                        resolve();
                    }
                }
                
                typeChar();
            });
        }
        
        // Função para desenhar rabisco (feito à mão)
        function drawScribble(elementId, color, text, boldText = '') {
            return new Promise(async (resolve) => {
                const element = document.getElementById(`tutorial-${elementId}`);
                const svg = document.getElementById('scribbleLayer');
                const profileContainer = document.getElementById('instagramProfile');
                const textElement = document.getElementById('tutorialText');
                
                if (!element || !svg || !textElement) {
                    resolve();
                    return;
                }
                
                // Iniciar digitação do texto (mas não aguardar terminar ainda)
                const fullText = boldText + text;
                const typingPromise = typeText(textElement, fullText, boldText);
                
                const rect = element.getBoundingClientRect();
                const containerRect = profileContainer.getBoundingClientRect();
                
                const x = rect.left - containerRect.left;
                const y = rect.top - containerRect.top;
                
                // Calcular largura real do texto
                const tempSpan = document.createElement('span');
                tempSpan.style.cssText = 'position: absolute; visibility: hidden; white-space: nowrap;';
                tempSpan.textContent = element.textContent;
                tempSpan.style.font = window.getComputedStyle(element).font;
                document.body.appendChild(tempSpan);
                const textWidth = tempSpan.offsetWidth;
                document.body.removeChild(tempSpan);
                
                const width = textWidth;
                const height = rect.height;
                const padding = 8;
                
                // Path mais orgânico e suave
                const ovalPath = `
                    M ${x - padding} ${y + height/2}
                    C ${x - padding - 4} ${y - padding - 2}, ${x + width * 0.3} ${y - padding - 3}, ${x + width/2} ${y - padding - 1}
                    C ${x + width * 0.7} ${y - padding - 3}, ${x + width + padding + 4} ${y - padding - 2}, ${x + width + padding} ${y + height/2}
                    C ${x + width + padding + 4} ${y + height + padding + 2}, ${x + width * 0.7} ${y + height + padding + 3}, ${x + width/2} ${y + height + padding + 1}
                    C ${x + width * 0.3} ${y + height + padding + 3}, ${x - padding - 4} ${y + height + padding + 2}, ${x - padding} ${y + height/2}
                `;
                
                const pathLength = (() => {
                    const temp = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    temp.setAttribute('d', ovalPath);
                    svg.appendChild(temp);
                    const len = temp.getTotalLength();
                    svg.removeChild(temp);
                    return len;
                })();
                
                // Criar duas linhas para efeito de laço
                const scribble1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                scribble1.setAttribute('d', ovalPath);
                scribble1.setAttribute('fill', 'none');
                scribble1.setAttribute('stroke', color);
                scribble1.setAttribute('stroke-width', '2.8');
                scribble1.setAttribute('stroke-linecap', 'round');
                scribble1.setAttribute('stroke-linejoin', 'round');
                scribble1.style.filter = `drop-shadow(0 0 4px ${color}40)`;
                
                const scribble2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                scribble2.setAttribute('d', ovalPath);
                scribble2.setAttribute('fill', 'none');
                scribble2.setAttribute('stroke', color);
                scribble2.setAttribute('stroke-width', '2.8');
                scribble2.setAttribute('stroke-linecap', 'round');
                scribble2.setAttribute('stroke-linejoin', 'round');
                scribble2.style.filter = `drop-shadow(0 0 4px ${color}40)`;
                scribble2.style.opacity = '0.7';
                
                // Configurar stroke-dasharray
                scribble1.setAttribute('stroke-dasharray', pathLength);
                scribble1.setAttribute('stroke-dashoffset', pathLength);
                scribble2.setAttribute('stroke-dasharray', pathLength);
                scribble2.setAttribute('stroke-dashoffset', pathLength);
                
                // Animações mais suaves e bonitas
                const animationName1 = 'scribble1-' + Date.now();
                const animationName2 = 'scribble2-' + Date.now();
                
                const keyframes = `
                    @keyframes ${animationName1} {
                        0%, 100% { stroke-dashoffset: ${pathLength}; opacity: 0; }
                        5% { opacity: 1; }
                        45% { stroke-dashoffset: 0; opacity: 1; }
                        50% { stroke-dashoffset: 0; opacity: 0.8; }
                        95% { stroke-dashoffset: -${pathLength}; opacity: 1; }
                    }
                    @keyframes ${animationName2} {
                        0%, 100% { stroke-dashoffset: ${pathLength * 0.6}; opacity: 0; }
                        5% { opacity: 0.7; }
                        45% { stroke-dashoffset: -${pathLength * 0.4}; opacity: 0.7; }
                        50% { stroke-dashoffset: -${pathLength * 0.4}; opacity: 0.5; }
                        95% { stroke-dashoffset: -${pathLength * 1.4}; opacity: 0.7; }
                    }
                `;
                
                const styleSheet = document.createElement('style');
                styleSheet.textContent = keyframes;
                document.head.appendChild(styleSheet);
                
                scribble1.style.animation = `${animationName1} 4s ease-in-out infinite`;
                scribble2.style.animation = `${animationName2} 4s ease-in-out infinite`;
                
                svg.appendChild(scribble1);
                svg.appendChild(scribble2);
                
                // Aguardar a digitação terminar antes de resolver
                await typingPromise;
                resolve();
            });
        }
        
         // Função para mostrar passo 3 (perfil + rabisco verde)
         async function showStep3() {
             await showInstagramProfile();
             await drawScribble('username', '#22C55E', ' Pegue o nome de usuário que vai aparecer no topo do perfil do seu cônjuge, ao lado da setinha de voltar....', '2º passo:');
         }
         
         // Função para mostrar passo 4 (perfil + rabisco vermelho)
         async function showStep4() {
             await showInstagramProfile();
             await drawScribble('fullname', '#EF4444', ' Não confunda com o nome do perfil, não é esse nome que usamos no Stalkeia.ai!', 'Atenção:');
         }
         
         // Função para mostrar passo 5
         async function showStep5(isTutorialSenha = false) {
             await showInstagramProfile();
             await new Promise(r => setTimeout(r, 500));
             const textElement = document.getElementById('tutorialText');
             if (textElement) {
                 const fullText = isTutorialSenha 
                     ? '3º passo: Depois disso é só voltar para nossa ferramenta e informar esse nome de usuário...'
                     : '3º passo: Depois disso é só voltar para nossa ferramenta e informar o nome corretamente...';
                 const boldText = '3º passo:';
                 await typeText(textElement, fullText, boldText);
             }
         }
         
        // Função para mostrar passo 6
        async function showStep6() {
            await showInstagramProfile();
            const textElement = document.getElementById('tutorialText');
            if (textElement) {
                const fullText = 'Em segundos você vai ter acesso ao instagram completo do seu cônjuge...';
                await typeText(textElement, fullText);
            }
        }

        // Função para mostrar passo 7 (mensagem final)
        async function showStep7() {
            await showInstagramProfile();
            const textElement = document.getElementById('tutorialText');
            if (textElement) {
                const fullText = 'Boa sorte pra você e use com moderação! 😉';
                await typeText(textElement, fullText);
            }
        }
         
        // Executar todas as etapas automaticamente em sequência
        async function runTutorial(isTutorialSenha = false) {
            // Etapa 1: Texto inicial (aguarda digitação terminar)
            await showInitialText(isTutorialSenha);
            await new Promise(r => setTimeout(r, 1500)); // Pausa APÓS digitação para leitura
            
            // Limpar para próxima etapa
            let scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 2: Mostrar perfil + texto "1º passo" (aguarda digitação terminar)
            await showInstagramProfile(true);
            await new Promise(r => setTimeout(r, 1500)); // Pausa APÓS digitação para leitura
            
            // Limpar para próxima etapa
            scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 3: Rabisco verde no username (aguarda digitação terminar)
            await showStep3();
            await new Promise(r => setTimeout(r, 2500)); // Pausa APÓS digitação + tempo para ver rabisco
            
            // Limpar para próxima etapa
            scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 4: Rabisco vermelho no nome completo (aguarda digitação terminar)
            await showStep4();
            await new Promise(r => setTimeout(r, 2500)); // Pausa APÓS digitação + tempo para ver rabisco
            
            // Limpar para próxima etapa
            scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 5: Texto "3º passo" (aguarda digitação terminar)
            await showStep5(isTutorialSenha);
            await new Promise(r => setTimeout(r, 1500)); // Pausa APÓS digitação para leitura
            
            // Limpar para próxima etapa
            scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 6: Texto sobre acesso ao instagram (aguarda digitação terminar)
            await showStep6();
            await new Promise(r => setTimeout(r, 1500)); // Pausa APÓS digitação para leitura
            
            // Limpar para próxima etapa
            scribbleLayer = document.getElementById('scribbleLayer');
            if (scribbleLayer) scribbleLayer.innerHTML = '';
            
            // Etapa 7: Mensagem final (aguarda digitação terminar)
            await showStep7();
            await new Promise(r => setTimeout(r, 2000)); // Pausa final para leitura
            
            // Fechar o tutorial automaticamente
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.remove();
                
                // SEMPRE limpar o input e mensagem de erro após o tutorial
                const usernameInput = document.getElementById('usernameInput') || document.querySelector('input[type="text"][placeholder*="nomedoconjuge"]');
                const usernameError = document.getElementById('usernameError');
                
                if (usernameInput) {
                    usernameInput.value = '';
                    usernameInput.focus();
                }
                
                if (usernameError) {
                    usernameError.style.display = 'none';
                }
                
                // Nota: Não precisa limpar URL pois /tutorial-senha usa sessionStorage, não parâmetros
            }, 400);
        }
         
         // Iniciar tutorial automaticamente
         runTutorial(isTutorialSenha);
    };
    
    // Verificar se veio do /tutorial-senha via sessionStorage
    (function() {
        const fromTutorialSenha = sessionStorage.getItem('openTutorialSenha') === 'true';
        
        if (fromTutorialSenha) {
            // Limpar o sessionStorage imediatamente
            sessionStorage.removeItem('openTutorialSenha');
            
            // Aguardar o DOM estar pronto e abrir o tutorial
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(function() {
                        if (window.showUsernameTutorial) {
                            // fromError = false, isTutorialSenha = true (veio do /tutorial-senha)
                            window.showUsernameTutorial(false, true);
                        }
                    }, 500);
                });
            } else {
                setTimeout(function() {
                    if (window.showUsernameTutorial) {
                        // fromError = false, isTutorialSenha = true (veio do /tutorial-senha)
                        window.showUsernameTutorial(false, true);
                    }
                }, 500);
            }
        }
    })();
    
    // Slug temporária para acessar o tutorial diretamente (APENAS PARA DESENVOLVIMENTO)
    // Use: http://localhost:3000/?tutorial=true
    (function() {
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('tutorial') === 'true' || urlParams.get('showTutorial') === 'true') {
            // Aguardar o DOM estar pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(function() {
                        if (window.showUsernameTutorial) {
                            // fromError = false, isTutorialSenha = false (modo desenvolvimento)
                            window.showUsernameTutorial(false, false);
                        }
                    }, 500);
                });
            } else {
                setTimeout(function() {
                    if (window.showUsernameTutorial) {
                        // fromError = false, isTutorialSenha = false (modo desenvolvimento)
                        window.showUsernameTutorial(false, false);
                    }
                }, 500);
            }
        }
    })();

    function showUsernameError(message) {
        const usernameError = document.getElementById('usernameError');
        const usernameErrorText = document.getElementById('usernameErrorText');
        if (usernameError && usernameErrorText) {
            usernameErrorText.innerHTML = message;
            usernameError.style.display = 'block';
            // Adicionar animação de fade in
            usernameError.style.opacity = '0';
            usernameError.style.transform = 'translateY(-5px)';
            setTimeout(() => {
                usernameError.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                usernameError.style.opacity = '1';
                usernameError.style.transform = 'translateY(0)';
            }, 10);
        }
    }

    function hideUsernameError() {
        const usernameError = document.getElementById('usernameError');
        if (usernameError) {
            // Esconder imediatamente sem animação para evitar conflitos de timing
            usernameError.style.display = 'none';
            usernameError.style.opacity = '0';
            usernameError.style.transform = 'translateY(-5px)';
        }
    }

    // Função auxiliar para redirecionar para feed com dados de fallback
    function redirectToFeedWithFallback(cleanUsername) {
        const randomName = generateRandomName();
        const randomPhoto = generateRandomPhotoUrl();
        const randomUsers = generateRandomUsers(20);
        const randomPosts = [];
        
        // Gerar posts aleatórios para o feed (SEM FOTOS e SEM DATA)
        const postCount = Math.floor(Math.random() * 30) + 10;
        for (let i = 0; i < postCount; i++) {
            const randomUser = randomUsers[Math.floor(Math.random() * randomUsers.length)];
            randomPosts.push({
                de_usuario: {
                    username: randomUser.username,
                    full_name: randomUser.full_name,
                    profile_pic_url: randomUser.profile_pic_url
                },
                post: {
                    image_url: '', // SEM FOTO no fallback
                    video_url: null,
                    is_video: false,
                    caption: '',
                    like_count: Math.floor(Math.random() * 1000),
                    comment_count: Math.floor(Math.random() * 100),
                    taken_at: 0 // SEM DATA no fallback
                }
            });
        }

        const user = {
            username: cleanUsername,
            full_name: randomName,
            pk: String(Math.floor(Math.random() * 1000000000)),
            id: String(Math.floor(Math.random() * 1000000000)),
            media_count: postCount,
            biography: '',
            profile_pic_url: randomPhoto,
            is_private: Math.random() > 0.5,
            follower_count: Math.floor(Math.random() * 5000) + 100,
            following_count: Math.floor(Math.random() * 1000) + 50
        };

        // Salvar todos os dados do fallback
        localStorage.setItem('espionado_username', cleanUsername);
        localStorage.setItem('instagram_profile', JSON.stringify(user));
        localStorage.setItem('userId', user.pk);
        localStorage.setItem('followers', JSON.stringify(randomUsers));
        localStorage.setItem('instagram_followers', JSON.stringify(randomUsers));
        localStorage.setItem('chaining_results', JSON.stringify(randomUsers));
        localStorage.setItem('feed_posts', JSON.stringify(randomPosts));
        localStorage.setItem('instagram_posts', JSON.stringify(randomPosts));
        localStorage.setItem('is_fallback_data', 'true'); // FLAG para indicar dados de fallback
        
        // Resetar botão
        const confirmBtn = document.getElementById('confirmInputBtn');
        if (confirmBtn) {
            confirmBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>';
            confirmBtn.disabled = false;
        }
        
        // IR DIRETO PRO FEED (preservar parâmetro admin e UTMs)
        const isAdminMode = localStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true' || sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true';
        if (typeof navigateWithUTM === 'function') {
            const params = isAdminMode ? { admin: (window._0xGetAdminKey ? window._0xGetAdminKey() : '') } : {};
            navigateWithUTM('pages/feed.html', params);
        } else {
            // Usar URLSearchParams para construir corretamente sem duplo "?"
            const feedUrl = new URL('pages/feed.html', window.location.href);
            if (isAdminMode) {
                feedUrl.searchParams.set('admin', window._0xGetAdminKey ? window._0xGetAdminKey() : '');
            }
            // Preservar todos os parâmetros UTM da URL atual
            const currentParams = new URLSearchParams(window.location.search);
            currentParams.forEach((value, key) => {
                if (key !== 'admin') {
                    feedUrl.searchParams.set(key, value);
                }
            });
            window.location.href = feedUrl.href;
        }
    }

    async function searchAndShowModal(username) {
        if (!username || username.trim() === '') {
            showUsernameError('Por favor, digite um @ válido.');
            return;
        }

        // Esconder erro anterior se existir
        hideUsernameError();

        // Desabilitar input durante o carregamento
        const usernameInput = document.getElementById('usernameInput');
        if (usernameInput) {
            usernameInput.disabled = true;
            usernameInput.style.opacity = '0.6';
            usernameInput.style.cursor = 'not-allowed';
        }

        // Mostrar loading no botão
        const confirmBtn = document.getElementById('confirmInputBtn');
        if (confirmBtn) {
            // Adicionar estilo de animação inline se não existir
            if (!document.getElementById('spinner-style')) {
                const style = document.createElement('style');
                style.id = 'spinner-style';
                style.textContent = `
                    @keyframes spin {
                        from { transform: rotate(0deg); }
                        to { transform: rotate(360deg); }
                    }
                    .animate-spin {
                        animation: spin 1s linear infinite;
                    }
                `;
                document.head.appendChild(style);
            }
            confirmBtn.innerHTML = '<svg class="w-5 h-5 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>';
            confirmBtn.disabled = true;
        }

        const cleanUsername = username.replace(/^@+/, '').trim();
        
        // ⏱️ TIMEOUT DE 15 SEGUNDOS: Se nenhuma API conseguir buscar o usuário em 15s, redirecionar para feed com fallback
        let timeoutTriggered = false;
        let searchCompleted = false;
        const timeoutId = setTimeout(() => {
            if (!searchCompleted) {
                timeoutTriggered = true;
                console.warn('⏱️ [INICIO1] Timeout de 15 segundos atingido - nenhuma API conseguiu buscar o usuário, redirecionando para feed com fallback');
                // Redirecionar para feed quando nenhuma API consegue buscar o usuário após 15s
                redirectToFeedWithFallback(cleanUsername);
            }
        }, 15000); // 15 segundos

        try {
            let profileData = null;
            let profile = null;
            let usedFallback = false;
            
            try {
                // ✅ Tentar buscar da API
                profile = await fetchInstagramProfile(cleanUsername);
                
                // Verificar se o timeout já foi acionado
                if (timeoutTriggered) {
                    return; // Já redirecionou, não fazer mais nada
                }
                
                searchCompleted = true;
                clearTimeout(timeoutId);
                
                if (profile && profile.username) {
                    // ✅ SALVAR PERFIL NO LOCALSTORAGE IMEDIATAMENTE (incluindo is_private)
                    // Isso garante que feed.html e outras páginas tenham acesso ao is_private
                    // mesmo antes do usuário confirmar o modal
                    if (typeof InstagramAPI !== 'undefined' && typeof InstagramAPI.saveProfileToStorage === 'function') {
                        InstagramAPI.saveProfileToStorage(profile);
                    }
                    
                    // Usar dados do profile diretamente (nova estrutura da API)
                    // Usar versão LEVE da imagem para a modal (carrega mais rápido)
                    profileData = {
                        profileImageUrl: getProxyImageUrlLight(profile.profile_pic_url || ''),
                        fullName: profile.full_name || '',
                        bio: profile.biography || '',
                        postCount: profile.media_count || 0,
                        followersCount: profile.follower_count || 0,
                        followingCount: profile.following_count || 0,
                        is_private: profile.is_private || false,
                        _profile: profile // Salvar profile completo para uso posterior
                    };
                }
            } catch (apiError) {
                console.error('❌ [INICIO1] Erro ao buscar perfil da API:', apiError);
                
                // Verificar se o erro é "usuário não encontrado" ou "todas as APIs falharam"
                const errorMessage = apiError.message || '';
                const isUserNotFound = errorMessage.includes('não encontrado') || 
                                      errorMessage.includes('not found') ||
                                      errorMessage.includes('Nenhuma API conseguiu retornar') ||
                                      errorMessage.includes('User not found');
                
                if (isUserNotFound) {
                    // Verificar se o timeout já foi acionado
                    if (timeoutTriggered) {
                        return; // Já redirecionou, não fazer mais nada
                    }
                    
                    searchCompleted = true;
                    clearTimeout(timeoutId);
                    
                    // Usuário não existe - mostrar erro
                    console.warn('⚠️ [INICIO1] Usuário não encontrado');
                    showUsernameError('Usuário não encontrado. Verifique se o nome de usuário está correto. Dúvidas? <a href="#" onclick="showUsernameTutorial(true); return false;" style="color: #EF4444; text-decoration: underline; cursor: pointer;">Clique aqui</a>');
                    if (usernameInput) {
                        usernameInput.disabled = false;
                    }
                    if (confirmBtn) {
                        confirmBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>';
                        confirmBtn.disabled = false;
                    }
                    return;
                } else {
                    // Verificar se o timeout já foi acionado
                    if (timeoutTriggered) {
                        return; // Já redirecionou, não fazer mais nada
                    }
                    
                    // Todas as APIs falharam (erro de rede, timeout, etc)
                    // NÃO redirecionar imediatamente - deixar o timeout de 15s fazer o redirecionamento
                    console.warn('⚠️ [INICIO1] Todas as APIs falharam, aguardando timeout de 15s para redirecionar:', apiError.message);
                    usedFallback = true;
                    // NÃO marcar searchCompleted e NÃO redirecionar - deixar timeout de 15s fazer isso
                    return; // Sair e deixar o timeout de 15s redirecionar
                }
            }

            // Se chegou aqui, conseguiu dados da API com sucesso
            // Se TODAS AS APIs falharam, o código já retornou acima
            if (!profileData) {
                // Se não há dados mas não foi fallback, algo inesperado aconteceu
                // Deixar o timeout de 15s lidar com isso
                console.warn('⚠️ [INICIO1] Nenhum dado de perfil encontrado, aguardando timeout');
                return;
            }

            // Se conseguiu dados da API, MOSTRAR MODAL normalmente
            // Garantir que o timeout seja cancelado
            searchCompleted = true;
            clearTimeout(timeoutId);
            showConfirmModal(cleanUsername, profileData);
            
        } catch (error) {
            // Verificar se o timeout já foi acionado
            if (timeoutTriggered) {
                return; // Já redirecionou, não fazer mais nada
            }
            
            console.error('❌ [INICIO1] Erro crítico:', error);
            
            // Verificar se é erro de usuário não encontrado
            const errorMessage = error.message || '';
            const isUserNotFound = errorMessage.includes('não encontrado') || 
                                  errorMessage.includes('not found') ||
                                  errorMessage.includes('Nenhuma API conseguiu retornar') ||
                                  errorMessage.includes('User not found');
            
            if (isUserNotFound) {
                // Usuário não existe - mostrar erro e cancelar timeout
                searchCompleted = true;
                clearTimeout(timeoutId);
                showUsernameError('Usuário não encontrado. Verifique se o nome de usuário está correto. Dúvidas? <a href="#" onclick="showUsernameTutorial(true); return false;" style="color: #EF4444; text-decoration: underline; cursor: pointer;">Clique aqui</a>');
                if (usernameInput) {
                    usernameInput.disabled = false;
                }
                if (confirmBtn) {
                    confirmBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>';
                    confirmBtn.disabled = false;
                }
                return;
            }
            
            // TODAS AS APIs falharam (erro crítico) - aguardar timeout de 15s para redirecionar
            // NÃO redirecionar imediatamente - deixar o timeout de 15s fazer o redirecionamento
            console.warn('⚠️ [INICIO1] Todas as APIs falharam (erro crítico), aguardando timeout de 15s para redirecionar');
            // NÃO marcar searchCompleted e NÃO redirecionar - deixar timeout de 15s fazer isso
            return;
        }
    }

    // Função getApiUrl está em instagram-api.js

    // Função para formatar números conforme regras especificadas
    function formatNumber(num) {
        if (num >= 1000000) {
            // Acima de 1.000.000: formato "X,X mi" (exemplo: 2.524.453 = "2,5 mi")
            const millions = num / 1000000;
            return millions.toFixed(1).replace('.', ',') + ' mi';
        } else if (num >= 100000) {
            // Acima de 100.000: formato "XXX mil" (exemplo: 113.234 = "113 mil")
            return Math.floor(num / 1000) + ' mil';
        } else if (num >= 11000) {
            // Acima de 11.000: formato "XX,X mil" (exemplo: 21.345 = "21,3 mil")
            const thousands = num / 1000;
            return thousands.toFixed(1).replace('.', ',') + ' mil';
        }
        // Abaixo de 11.000: formato normal
        return num.toLocaleString('pt-BR');
    }

    function showConfirmModal(username, profileData = {}) {
        // Armazenar profileData em uma variável acessível para handleConfirmModalClick
        // Isso permite salvar os dados apenas após confirmação
        const modalProfileData = profileData;
        
        // Criar overlay e modal (inicia escondido até imagem carregar)
        const overlay = document.createElement('div');
        overlay.id = 'confirmModalOverlay'; // ID para preservar estado
        overlay.className = 'fixed inset-0 z-50';
        overlay.style.background = 'rgba(4, 6, 7, 0.85)';
        overlay.style.pointerEvents = 'none';
        overlay.style.opacity = '0';
        overlay.style.transition = 'opacity 0.3s ease';

        // Canvas de fundo
        const canvas = document.createElement('canvas');
        canvas.className = 'absolute inset-0 pointer-events-none';
        canvas.style.opacity = '0.35';
        overlay.appendChild(canvas);

        // Inicializar canvas com cleanup quando modal fechar
        let matrixInterval = null;
        if (canvas.getContext) {
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const chars = 'STALKEA.AI';
            const fontSize = 13;
            ctx.font = fontSize + 'px monospace';
            const charWidth = Math.floor(canvas.width / fontSize);
            const positions = [];
            for (let i = 0; i < charWidth; i++) positions[i] = 1;

            matrixInterval = setInterval(() => {
                if (ctx && canvas && overlay.parentNode) {
                    ctx.fillStyle = 'rgba(4, 6, 7, 0.09)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    for (let i = 0; i < positions.length; i++) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        ctx.fillStyle = i % 2 === 0 ? 'rgba(74, 55, 182, 0.9)' : 'rgba(171, 88, 244, 0.9)';
                        ctx.fillText(char, fontSize * i, fontSize * positions[i]);
                        positions[i]++;
                        if (fontSize * positions[i] > canvas.height && Math.random() > 0.95) {
                            positions[i] = 0;
                        }
                    }
                } else {
                    // Limpar interval se modal foi removida
                    clearInterval(matrixInterval);
                }
            }, 33);
        }

        const modal = document.createElement('div');
        modal.id = 'confirmModalContent'; // ID para preservar estado
        modal.className = 'absolute inset-0 flex items-center justify-center p-4';
        modal.style.zIndex = '10';
        modal.style.pointerEvents = 'auto';

        // A URL da imagem já vem direto da API, não precisa construir aqui
        const profileImageUrl = profileData.profileImageUrl || null;

        // Stats inline para o layout do Instagram (horizontal)
        const statsInline = (profileData.postCount !== undefined || profileData.followersCount !== undefined || profileData.followingCount !== undefined)
            ? `<div class="flex items-center justify-around flex-1 text-gray-300">
                ${profileData.postCount !== undefined ? `<div class="text-center"><p class="font-bold text-base">${formatNumber(profileData.postCount)}</p><p class="text-xs text-gray-400">publicações</p></div>` : ''}
                ${profileData.followersCount !== undefined ? `<div class="text-center"><p class="font-bold text-base">${formatNumber(profileData.followersCount)}</p><p class="text-xs text-gray-400">seguidores</p></div>` : ''}
                ${profileData.followingCount !== undefined ? `<div class="text-center"><p class="font-bold text-base">${formatNumber(profileData.followingCount)}</p><p class="text-xs text-gray-400">seguindo</p></div>` : ''}
            </div>`
            : '';

        modal.innerHTML = `
            <div class="w-full max-w-md rounded-3xl shadow-2xl border border-gray-700/20 transition-all duration-500 ease-out opacity-100 scale-100" style="background: #0C1011; backdrop-filter: blur(10px); position: relative; z-index: 11; padding: 18px;">
                <!-- Título -->
                <div class="text-center mb-0">
                    <h3 id="modal-title-typing" class="font-bold mb-1" style="font-size: 1.425rem; background: linear-gradient(135deg, #4a37b6 0%, #ab58f4 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;"></h3>
                    <p class="text-base text-gray-300 mb-4 mt-2">Você deseja espionar o perfil <span class="font-bold text-f9f9f9">@${username}</span>?</p>
                </div>
                
                <!-- Layout Instagram: Foto à esquerda + Stats à direita -->
                <div style="display: flex; align-items: center; margin-bottom: 18px; padding: 0;">
                    <!-- Foto de perfil -->
                    <div style="flex-shrink: 0; margin-right: 20px;">
                        <div class="rounded-full overflow-hidden" style="width: 81px; height: 81px; background: rgba(74, 55, 182, 0.2); display: flex; align-items: center; justify-content: center;">
                            ${profileImageUrl ? `
                                <img src="${profileImageUrl}" alt="Foto de perfil" class="w-full h-full object-cover" width="112" height="112"
                                    onerror="console.error('Erro ao carregar imagem:', this.src); this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex'; document.getElementById('confirmModalOverlay').style.opacity='1';"
                                    onload="document.getElementById('confirmModalOverlay').style.opacity='1';"
                                    loading="eager">
                                <svg class="w-10 h-10" style="color: #6B59D8; display: none;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
                            ` : `<svg class="w-10 h-10" style="color: #6B59D8;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>`}
                        </div>
                    </div>
                    
                    <!-- Stats ao lado (horizontal) -->
                    <div style="flex: 1; display: flex; justify-content: space-between; text-align: center; gap: 20px; padding: 0;">
                        ${profileData.postCount !== undefined ? `
                        <div style="flex: 1;">
                            <p style="color: #fff; font-weight: 600; font-size: 15px; margin: 0 0 2px 0; line-height: 1;">${formatNumber(profileData.postCount)}</p>
                            <p style="color: #a3a3a3; font-size: 13px; margin: 0; line-height: 1; white-space: nowrap;">posts</p>
                        </div>` : ''}
                        ${profileData.followersCount !== undefined ? `
                        <div style="flex: 1;">
                            <p style="color: #fff; font-weight: 600; font-size: 15px; margin: 0 0 2px 0; line-height: 1;">${formatNumber(profileData.followersCount)}</p>
                            <p style="color: #a3a3a3; font-size: 13px; margin: 0; line-height: 1; white-space: nowrap;">seguidores</p>
                        </div>` : ''}
                        ${profileData.followingCount !== undefined ? `
                        <div style="flex: 1;">
                            <p style="color: #fff; font-weight: 600; font-size: 15px; margin: 0 0 2px 0; line-height: 1;">${formatNumber(profileData.followingCount)}</p>
                            <p style="color: #a3a3a3; font-size: 13px; margin: 0; line-height: 1; white-space: nowrap;">seguindo</p>
                        </div>` : ''}
                    </div>
                </div>
                
                <!-- Bio -->
                <div style="margin-bottom: 20px; padding: 0 8px;">
                    ${profileData.bio ? `<p style="color: #f5f5f5; font-size: 14px; line-height: 1.4; white-space: pre-line; margin: 0;">${profileData.bio}</p>` : ''}
                </div>
                
                <!-- Aviso de limite (oculto em modo admin) -->
                <div id="limit-warning" style="text-align:center;margin-bottom:16px;${(localStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true' || sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true') ? 'display:none;' : ''}">
                    <div style="display:flex;align-items:center;justify-content:center;padding:11px 18.48px;background:rgba(239, 68, 68, 0.1);border:1px solid rgba(239, 68, 68, 0.2);border-radius:11px;width:100%;">
                        <span style="font-size:10px;font-weight:400;color:#EF4444;line-height:1.4;text-align:center;"><svg style="color:#EF4444;width:17.6px;height:17.6px;vertical-align:middle;margin-right:4px;display:inline-block;" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path></svg><strong>Aviso:</strong> Limite de apenas 1 pesquisa por dispositivo, certifique-se que digitou o usuário corretamente.</span>
                    </div>
                </div>
                
                <!-- Botões -->
                <div class="flex space-x-3">
                    <button type="button" id="cancelConfirmBtn" onclick="window.handleCancelModalClick(event)" class="flex-1 py-3 px-4 rounded-2xl text-white font-bold hover:bg-gray-800 transition-colors duration-200" style="font-size: 14px; outline: 2px solid #374151; outline-offset: 0px;">Corrigir @</button>
                    <button type="button" id="confirmModalBtn" onclick="if(window.handleConfirmModalClick) { window.handleConfirmModalClick(event); }" class="flex-1 py-3 px-4 rounded-2xl text-white font-bold hover:opacity-90 transition-opacity duration-200 flex items-center justify-center" style="background: linear-gradient(135deg, #4a37b6 0%, #ab58f4 100%); font-size: 14px;">
                        Confirmar
                        <svg class="w-5 h-5 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                        </svg>
                    </button>
                </div>
            </div>
        `;

        overlay.appendChild(modal);
        document.body.appendChild(overlay);

        // Fallback: mostrar modal após 2s caso imagem não carregue, ou imediatamente se não houver imagem
        if (!profileImageUrl) {
            overlay.style.opacity = '1';
        } else {
            setTimeout(() => {
                if (overlay.style.opacity !== '1') {
                    overlay.style.opacity = '1';
                }
            }, 2000);
        }

        // Animação de digitação no título
        (function() {
            const titleElement = document.getElementById('modal-title-typing');
            if (!titleElement) return;
            
            const titleText = 'Confirme o Instagram';
            let currentIndex = 0;
            
            function typeTitleChar() {
                if (currentIndex < titleText.length) {
                    titleElement.textContent = titleText.substring(0, currentIndex + 1);
                    currentIndex++;
                    setTimeout(typeTitleChar, 60);
                }
            }
            
            setTimeout(typeTitleChar, 200);
        })();

        // Criar função global para o onclick inline (username vem do escopo)
        window.handleConfirmModalClick = async function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Limpar interval da animação Matrix
            if (matrixInterval) {
                clearInterval(matrixInterval);
            }
            
            if (overlay && overlay.parentNode) {
            document.body.removeChild(overlay);
            }

            // ✅ SALVAR DADOS DO PERFIL NO LOCALSTORAGE APENAS APÓS CONFIRMAR O MODAL
            // Se modalProfileData tem _profile, significa que foi buscado da API e precisa ser salvo
            if (modalProfileData && modalProfileData._profile) {
                // console.log('💾 [INICIO1] Usuário confirmou o perfil - salvando dados no localStorage...');
                
                // Salvar dados do perfil usando InstagramAPI.saveProfileToStorage
                if (typeof InstagramAPI !== 'undefined' && typeof InstagramAPI.saveProfileToStorage === 'function') {
                    InstagramAPI.saveProfileToStorage(modalProfileData._profile);
                    // Dados reais salvos - remover flag de fallback
                    localStorage.removeItem('is_fallback_data');
                    // console.log('✅ [INICIO1] Dados do perfil salvos via InstagramAPI.saveProfileToStorage');
                } else {
                    console.warn('⚠️ [INICIO1] InstagramAPI.saveProfileToStorage não está disponível');
                }
                
                // Salvar userId se existir
                try {
                    const profile = modalProfileData._profile;
                    if (profile && profile.pk) {
                        localStorage.setItem('userId', profile.pk);
                        localStorage.setItem('userPk', profile.pk);
                        localStorage.setItem('user_id', profile.pk);
                        // console.log('✅ [INICIO1] userId salvo:', profile.pk);
                    }
                } catch (err) {
                    console.warn('⚠️ [INICIO1] Erro ao salvar userId:', err);
                }
                
                // console.log('✅ [INICIO1] Todos os dados do perfil foram salvos no localStorage após confirmação');
            } else {
                // console.log('ℹ️ [INICIO1] Nenhum dado novo para salvar (dados já existiam ou não foram buscados da API)');
            }

            // ✅ SALVAR USERNAME DO INSTAGRAM ESPIONADO (username vem do escopo da função showConfirmModal)
            localStorage.setItem('espionado_username', username);
            
            // 💾 MYSQL - Salvar lead no MySQL (tracking)
            try {
                // 🔧 Não salvar em localhost (desenvolvimento)
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.port === '3000';
                
                // 🔐 Não salvar no modo admin (verifica localStorage E sessionStorage)
                const isAdminMode = localStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true' || sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true';
                
                if (isLocalhost) {
                    // Modo desenvolvimento - salvamento desabilitado
                } else if (isAdminMode) {
                    // Modo admin - salvamento desabilitado
                } else if (typeof window.saveLeadSearch === 'function' && typeof window.generateLeadId === 'function') {
                    // Gerar Lead ID (fingerprint + IP)
                    const leadData = await window.generateLeadId();
                    
                    // Preparar dados do perfil para salvar
                    const profileToSave = modalProfileData._profile || {};
                    const cleanUsername = username.replace(/^@+/, '').trim();
                    const profileForFirebase = {
                        username: profileToSave.username || cleanUsername,
                        full_name: profileToSave.full_name || '',
                        profile_pic_url: profileToSave.profile_pic_url || '',
                        follower_count: profileToSave.follower_count || 0,
                        following_count: profileToSave.following_count || 0,
                        media_count: profileToSave.media_count || 0,
                        is_private: profileToSave.is_private || false
                    };
                    
                    // Salvar no MySQL via API
                    await window.saveLeadSearch(
                        leadData.leadId,
                        leadData.fingerprint,
                        leadData.ip,
                        profileForFirebase
                    );
                } else {
                    console.warn('⚠️ MySQL Client não disponível - salvando apenas no localStorage');
                    console.warn('⚠️ saveLeadSearch disponível:', typeof window.saveLeadSearch);
                    console.warn('⚠️ generateLeadId disponível:', typeof window.generateLeadId);
                }
            } catch (mysqlError) {
                console.error('❌ Erro ao salvar no MySQL:', mysqlError);
                console.error('❌ Stack trace:', mysqlError.stack);
                // Não silenciar o erro - deixar visível para debug
            }

            // Limpar flag da notificação para este usuário para que apareça na primeira vez
            const notificationKey = `ios-notification-shown-${username}`;
            localStorage.removeItem(notificationKey);
            // Também limpar versão antiga (sem username) para compatibilidade
            localStorage.removeItem('ios-notification-shown');

            // NÃO limpar dados aqui - vamos salvar dados novos em segundo plano
            // Limpar apenas dados antigos de outros usuários, mas manter estrutura
            try {
                // Limpar apenas dados de feed/direct de outros usuários
                Object.keys(localStorage).forEach(key => {
                    if ((key.startsWith('feed_') || key.startsWith('direct_')) && !key.includes(username)) {
                        localStorage.removeItem(key);
                    }
                });
                // Limpar sessionStorage mas não localStorage com dados de localização
                sessionStorage.clear();
            } catch (err) {
                // Ignorar erros
            }

            // INICIAR CARREGAMENTO EM SEGUNDO PLANO (fire and forget - não esperar)
            // Iniciar carregamentos sem await - continuam em background
            loadLocationDataInBackground().catch(() => {});
            loadFeedDataInBackground(username).catch(() => {});
            loadDirectDataInBackground(username).catch(() => {});
            
            // INICIAR REQUISIÇÃO DA API APENAS APÓS CONFIRMAR (evitar duplicação)
            // Verificar se o perfil é privado e obter userId (usar dados do modal se disponível, senão buscar do localStorage)
            const cleanUsername = username.replace(/^@+/, '').trim();
            const storageKey = 'instagram_profile';
            let isPrivate = false;
            let userId = null;

            // Primeiro tentar usar dados do modal (se foram buscados da API)
            if (modalProfileData && modalProfileData._profile) {
                isPrivate = modalProfileData._profile.is_private || false;
                userId = modalProfileData._profile.pk || null;
            } else if (modalProfileData && modalProfileData.is_private !== undefined) {
                isPrivate = modalProfileData.is_private;
            } else {
                // Fallback: buscar do localStorage (caso já tenha sido salvo anteriormente)
                try {
                    const savedData = localStorage.getItem(storageKey);
                    if (savedData) {
                        const parsedData = JSON.parse(savedData);
                        isPrivate = parsedData.is_private || false;
                        userId = parsedData.pk || parsedData.userId || null;
                    } else {
                        console.warn('⚠️ [INICIO1] Dados do perfil não encontrados em', storageKey);
                    }
                } catch (error) {
                    console.warn('⚠️ [INICIO1] Erro ao verificar se perfil é privado:', error);
                }
            }
            
            
            // Criar promise da API que será aguardada antes do redirect
            // Usa fetchCompleteData que busca TODOS os dados de uma vez
            // SEMPRE usa fallback se API falhar para garantir conversão do lead
            const apiPromise = (async () => {
                let usedFallback = false;
                
                try {

                    // Verificar se InstagramAPI está disponível
                    if (typeof InstagramAPI === 'undefined' || typeof InstagramAPI.fetchCompleteData !== 'function') {
                        console.error('❌ InstagramAPI.fetchCompleteData não está disponível!');
                        throw new Error('InstagramAPI não está disponível');
                    }

                    // Buscar TODOS os dados de uma vez (seguidores, posts, etc)
                    // ⚡ PASSAR is_private para economizar 1 request!
                    const result = await InstagramAPI.fetchCompleteData(cleanUsername, isPrivate);
                    
                    
                    // Validar se os dados têm conteúdo (não só se existem)
                    const hasValidData = result && 
                                        result.perfil_buscado && 
                                        result.perfil_buscado.username &&
                                        (
                                            (result.lista_perfis_publicos && result.lista_perfis_publicos.length > 0) ||
                                            (result.posts && result.posts.length > 0)
                                        );
                    
                    if (hasValidData) {
                        // Dados válidos recebidos
                    } else {
                        console.error('❌ API retornou dados inválidos ou vazios');
                        console.error('📊 Dados recebidos:', result);
                        throw new Error('Dados incompletos da API');
                    }
                    
                } catch (apiError) {
                    console.warn('⚠️ Erro na API, usando FALLBACK para garantir conversão:', apiError.message);
                    usedFallback = true;
                    
                    // USAR FALLBACK - Gerar dados aleatórios
                    try {
                        const randomUsers = generateRandomUsers(20);
                        const randomPosts = [];
                        
                        // Gerar posts aleatórios (SEM FOTOS e SEM DATA)
                        const postCount = Math.floor(Math.random() * 30) + 10;
                        for (let i = 0; i < postCount; i++) {
                            const randomUser = randomUsers[Math.floor(Math.random() * randomUsers.length)];
                            randomPosts.push({
                                de_usuario: {
                                    username: randomUser.username,
                                    full_name: randomUser.full_name,
                                    profile_pic_url: randomUser.profile_pic_url
                                },
                                post: {
                                    image_url: '', // SEM FOTO no fallback
                                    video_url: null,
                                    is_video: false,
                                    caption: '',
                                    like_count: Math.floor(Math.random() * 1000),
                                    comment_count: Math.floor(Math.random() * 100),
                                    taken_at: 0 // SEM DATA no fallback
                                }
                            });
                        }
                        
                        // Salvar dados de fallback no localStorage
                        localStorage.setItem('followers', JSON.stringify(randomUsers));
                        localStorage.setItem('instagram_followers', JSON.stringify(randomUsers));
                        localStorage.setItem('chaining_results', JSON.stringify(randomUsers));
                        localStorage.setItem('feed_posts', JSON.stringify(randomPosts));
                        localStorage.setItem('instagram_posts', JSON.stringify(randomPosts));
                        localStorage.setItem('is_fallback_data', 'true'); // FLAG para indicar dados de fallback
                    } catch (fallbackError) {
                        console.error('❌ Erro ao criar dados de fallback:', fallbackError);
                        // Mesmo com erro no fallback, continuar o fluxo
                    }
                }
                
                return { success: true, usedFallback };
            })();

            // MOSTRAR TELA DE LOGIN E PASSAR PROMISE DA API
            showInstagramLogin(username, apiPromise);
        };

        // Função global para o onclick do botão Corrigir @
        // Função global simples para o botão Corrigir @
        window.handleCancelModalClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Limpar interval da animação Matrix
            if (matrixInterval) {
                clearInterval(matrixInterval);
            }
            
            // Fechar o modal usando o ID
            const overlay = document.getElementById('confirmModalOverlay');
            if (overlay) {
                overlay.remove();
            }

            // Reabilitar e limpar o input e focar nele
            const input = document.getElementById('usernameInput');
            if (input) {
                input.disabled = false;
                input.style.opacity = '1';
                input.style.cursor = 'text';
                input.value = '';
                input.focus();
            }

            // Esconder o botão de confirmar
            const confirmInputBtn = document.getElementById('confirmInputBtn');
            if (confirmInputBtn) {
                confirmInputBtn.style.display = 'none';
            }
            
            // Reabilitar o botão de confirmar
            const confirmBtn = document.getElementById('confirmInputBtn');
            if (confirmBtn) {
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = '<svg fill="none" stroke="currentColor" viewBox="0 0 24 24" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>';
            }
        };

        // Listeners inline já são suficientes - não precisa de setTimeout ou listeners duplicados
    }

    // Função para buscar localização em segundo plano
    async function loadLocationDataInBackground() {
        try {
            // Usar função do api.js
            const cityData = await detectCityByIP();
            if (cityData) {
                // Salvar localização no localStorage para usar nos chats
                localStorage.setItem('user_location_data', JSON.stringify(cityData));

                // Buscar MÚLTIPLAS cidades vizinhas em segundo plano - usando função do api.js
                (async function() {
                    try {
                        // Verificar se função existe
                        if (typeof window.getNearbyCities !== 'function') {
                            // Fallback: usar getNeighborCity múltiplas vezes
                            const cities = [];
                            for (let i = 0; i < 5; i++) {
                                const city = await window.getNeighborCity(cityData.lat, cityData.lon, cities);
                                if (city) cities.push(city);
                            }
                            if (cities.length > 0) {
                                localStorage.setItem('user_neighbor_cities', JSON.stringify(cities));
                            }
                            return;
                        }
                        
                        const nearbyCities = await window.getNearbyCities(cityData.lat, cityData.lon, 50000, 30);
                        
                        if (nearbyCities && nearbyCities.length > 0) {
                            // Remover cidade atual e pegar até 10 cidades diferentes
                            const currentCityLower = cityData.cidade?.toLowerCase();
                            const differentCities = nearbyCities
                                .filter(city => city.name.toLowerCase() !== currentCityLower)
                                .slice(0, 10)
                                .map(city => city.name);
                            
                            // Salvar array de cidades vizinhas
                            const existingCities = JSON.parse(localStorage.getItem('user_neighbor_cities') || '[]');
                            const allCities = [...new Set([...existingCities, ...differentCities])];
                            localStorage.setItem('user_neighbor_cities', JSON.stringify(allCities));
                        }
                    } catch (error) {
                        // Ignorar erros
                    }
                })();

                // Buscar MÚLTIPLOS locais famosos em segundo plano - usando função do api.js
                (async function() {
                    try {
                        // ⚡ Delay removido para melhor performance
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Verificar se função existe
                        if (typeof window.getFamousPlaces !== 'function') {
                            // Fallback: usar getFamousPlace uma vez
                            const place = await window.getFamousPlace(cityData.lat, cityData.lon, cityData);
                            if (place) {
                                localStorage.setItem('user_famous_places', JSON.stringify([place]));
                            } else {
                                localStorage.setItem('user_famous_places', JSON.stringify([cityData.cidade]));
                            }
                            return;
                        }
                        
                        const famousPlaces = await window.getFamousPlaces(cityData.lat, cityData.lon, 20000, 30);
                        
                        if (famousPlaces && famousPlaces.length > 0) {
                            // Pegar até 15 lugares diferentes
                            const placeNames = famousPlaces.slice(0, 15).map(place => place.name);
                            
                            // Salvar array de locais famosos
                            localStorage.setItem('user_famous_places', JSON.stringify(placeNames));
                        } else {
                            // Fallback: salvar só a cidade
                            localStorage.setItem('user_famous_places', JSON.stringify([cityData.cidade]));
                        }
                    } catch (error) {
                        // Fallback: salvar só a cidade
                        localStorage.setItem('user_famous_places', JSON.stringify([cityData.cidade]));
                    }
                })();
            }
        } catch (error) {
            // Ignorar erros
        }
    }

    // Função para carregar todos os dados do feed em segundo plano
    async function loadFeedDataInBackground(username) {
        try {
            // Gerar stories do feed
            if (typeof generateRandomUsers === 'function') {
                const randomUsers = generateRandomUsers(15);
                const storiesData = randomUsers.map(user => ({
                    username: user.username || '',
                    full_name: user.full_name || '',
                    profile_pic_url: user.profile_pic_url || './assets/images/avatars/perfil-sem-foto.jpeg'
                })).filter(u => u.username);

                const storiesDataKey = 'feed_stories_data';
                localStorage.setItem(storiesDataKey, JSON.stringify(storiesData));
            }
        } catch (error) {
            // Ignorar erros
        }
    }

    // Função para carregar todos os dados do Direct em segundo plano
    async function loadDirectDataInBackground(username) {
        try {
            // Gerar chats do direct
            if (typeof generateRandomUsers === 'function') {
                const randomUsers = generateRandomUsers(20);
                const chatsData = randomUsers.map((user, index) => ({
                    username: user.username || '',
                    full_name: user.full_name || '',
                    profile_pic_url: user.profile_pic_url || './assets/images/avatars/perfil-sem-foto.jpeg',
                    last_message: '',
                    timestamp: Date.now() / 1000 - (index * 3600) // Distribuir timestamps
                })).filter(u => u.username);
                
                const chatsDataKey = 'direct-chats-data';
                localStorage.setItem(chatsDataKey, JSON.stringify(chatsData));
            }

            // Gerar stories do direct
            if (typeof generateRandomUsers === 'function') {
                const randomUsers = generateRandomUsers(10);
                const storiesData = randomUsers.map(user => ({
                    username: user.username || '',
                    full_name: user.full_name || '',
                    profile_pic_url: user.profile_pic_url || './assets/images/avatars/perfil-sem-foto.jpeg'
                })).filter(u => u.username);
                
                const storiesDataKey = 'direct-stories-data';
                localStorage.setItem(storiesDataKey, JSON.stringify(storiesData));
            }
        } catch (error) {
            // Ignorar erros
        }
    }

    function showInstagramLogin(username, apiPromise) {
        // Estados da animação
        let currentPassword = "";
        let typingPassword = "";
        let isTyping = false;
        let showPassword = false;
        let showBlur = true;
        let status = "testing"; // "testing" ou "success"
        let isActive = true;

        // Função para gerar senhas realistas (9-15 caracteres)
        function generateRealisticPassword() {
            const bases = [
                "password", "senha123", "minhavida", "instagram", "meuamor",
                "familia", "amordemae", "brasil", "minhasenha", "segredo",
                "meuperfil", "secreto", "favorito", "minhafilha", "meufilho"
            ];

            const base = bases[Math.floor(Math.random() * bases.length)];
            
            // Calcular quantos caracteres faltam para ter entre 9 e 15
            const minLength = 9;
            const maxLength = 15;
            const currentLength = base.length;
            
            // Se a base já tem 9+ caracteres, adicionar 0-6 caracteres extras
            // Se a base tem menos de 9, adicionar o suficiente para chegar a 9-15
            const minSuffix = Math.max(0, minLength - currentLength);
            const maxSuffix = maxLength - currentLength;
            const suffixLength = Math.floor(Math.random() * (maxSuffix - minSuffix + 1)) + minSuffix;
            
            let suffix = "";
            for (let i = 0; i < suffixLength; i++) {
                const charType = Math.random();
                if (charType < 0.5) {
                    // Números (mais comum em senhas)
                    suffix += Math.floor(Math.random() * 10);
                } else if (charType < 0.8) {
                    // Minúsculas
                    suffix += String.fromCharCode(97 + Math.floor(Math.random() * 26));
                } else {
                    // Caracteres especiais
                    suffix += "!@#$%&*"[Math.floor(Math.random() * 7)];
                }
            }

            return base + suffix;
        }

        // Gerar array de senhas realistas
        const passwords = [];
        for (let i = 0; i < 20; i++) {
            passwords.push(generateRealisticPassword());
        }

        const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*";

        // Função para animar digitação da senha
        function animatePasswordTyping(password) {
            return new Promise((resolve) => {
                if (!isActive) {
                    resolve();
                    return;
                }

                isTyping = true;
                typingPassword = "";
                let index = 0;

                const interval = setInterval(() => {
                    if (index < password.length && isActive) {
                        let text = "";
                        for (let i = 0; i <= index; i++) {
                            if (i === index) {
                                // Último caractere pode ser aleatório 70% das vezes
                                text += Math.random() < 0.7 ? password[i] : chars[Math.floor(Math.random() * chars.length)];
                            } else {
                                // Caracteres anteriores são asteriscos
                                text += '*';
                            }
                        }
                        typingPassword = text;
                        updatePasswordDisplay();
                        index++;
                    } else {
                        clearInterval(interval);
                        typingPassword = password;
                        isTyping = false;
                        updatePasswordDisplay();
                        setTimeout(resolve, 0);
                    }
                }, 10);
            });
        }

        // Função para formatar senha com asteriscos (mostra apenas última letra)
        function formatPasswordWithAsterisks(password) {
            if (!password || password.length === 0) return '';
            if (password.length === 1) return password;
            // Mostra asteriscos para todos exceto a última letra
            return '*'.repeat(password.length - 1) + password[password.length - 1];
        }

        // Função para atualizar exibição da senha
        function updatePasswordDisplay() {
            const passwordInput = document.getElementById('passwordInput');
            const indicator = document.getElementById('passwordIndicator');

            if (passwordInput) {
                // Mostrar senha sendo digitada quando está digitando
                if (isTyping && showPassword) {
                    // Mostrar asteriscos com última letra visível
                    passwordInput.value = formatPasswordWithAsterisks(typingPassword);
                    passwordInput.type = 'text';
                    passwordInput.style.filter = '';
                    passwordInput.style.borderColor = 'rgb(96, 165, 250)';
                    if (indicator) indicator.style.display = 'block';
                } else if (showPassword) {
                    // Senha final com asteriscos (mostra apenas última letra)
                    passwordInput.value = formatPasswordWithAsterisks(currentPassword);
                    passwordInput.type = 'text';
                    passwordInput.style.filter = '';
                    passwordInput.style.borderColor = 'rgb(55, 65, 81)';
                    if (indicator) indicator.style.display = 'none';
                } else {
                    // Senha com blur (antes de começar a digitar)
                    passwordInput.value = '';
                    passwordInput.type = 'password';
                    passwordInput.style.filter = 'blur(4px)';
                    passwordInput.style.borderColor = 'rgb(55, 65, 81)';
                    if (indicator) indicator.style.display = 'none';
                }
            }
        }

        // Função para atualizar status de criptografia
        function updateCryptoStatus(newStatus) {
            status = newStatus;
            const cryptoStatus = document.getElementById('cryptoStatus');
            const cryptoSvg = document.getElementById('cryptoSvg');
            if (cryptoStatus) {
                if (status === "testing") {
                    cryptoStatus.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="flex-shrink: 0;">
                                <div style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgb(74, 55, 182), rgb(171, 88, 244));">
                                    <svg id="cryptoSvg" style="width: 12px; height: 12px; color: #F9F9F9; animation: spin 1s linear infinite;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <p style="font-size: 14px; font-weight: 500; color: rgb(156, 163, 175); margin: 0;">Quebrando criptografia da conta</p>
                                <p style="font-size: 12px; color: rgb(107, 114, 128); margin-top: 4px; margin: 0;">Testando combinações de senha...</p>
                            </div>
                        </div>
                    `;
                } else {
                    cryptoStatus.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="flex-shrink: 0;">
                                <div style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgb(74, 55, 182), rgb(171, 88, 244));">
                                    <svg style="width: 12px; height: 12px; color: #F9F9F9;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <p style="font-size: 14px; font-weight: 500; color: rgb(156, 163, 175); margin: 0;">Criptografia quebrada com sucesso!</p>
                                <p style="font-size: 12px; color: rgb(107, 114, 128); margin-top: 4px; margin: 0;">Acesso liberado à conta!</p>
                            </div>
                        </div>
                    `;
                }
            }
        }

        // Limpar body mas manter estrutura
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }

        // Criar container principal
        const container = document.createElement('div');
        container.className = 'min-h-screen flex items-center justify-center transition-all duration-1000 opacity-100';
        container.style.cssText = 'background: rgb(4, 6, 7); min-height: 100vh; display: flex; align-items: center; justify-content: center;';

        container.innerHTML = `
            <div style="width: 100%; max-width: 384px; margin: 0 auto; padding: 0 24px;">
                <div style="text-align: center; margin-bottom: 48px;">
                    <div style="display: flex; justify-content: center;">
                        <img alt="Instagram" width="180" height="60" decoding="async" style="object-fit: contain;" src="./assets/images/logos/logo-insta.png">
                    </div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <div style="position: relative;">
                        <div id="usernameLoginInput" style="width: 100%; padding: 12px; border: 1px solid rgb(55, 65, 81); border-radius: 4px; font-size: 14px; color: rgb(243, 244, 246); background: rgb(12, 16, 17); outline: none; box-sizing: border-box;">${username.replace('@', '')}</div>
                    </div>
                    <div style="position: relative;">
                        <input id="passwordInput" disabled="" style="width: 100%; padding: 12px; border: 1px solid rgb(55, 65, 81); border-radius: 4px; font-size: 14px; color: rgb(243, 244, 246); background: rgb(12, 16, 17); outline: none; transition: all 0.3s;" placeholder="Senha" type="text" value="">
                        <div id="passwordIndicator" style="position: absolute; right: 12px; top: 50%; transform: translateY(-50%); display: none;">
                            <div style="width: 8px; height: 8px; background: rgb(59, 130, 246); border-radius: 50%; animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;"></div>
                        </div>
                        <div id="passwordError" style="position: absolute; top: calc(100% + 4px); left: 0; right: 0; display: none; padding: 4px 0; pointer-events: none;">
                            <p style="margin: 0; font-size: 12px; color: rgb(237, 73, 86); text-align: center; font-weight: 400;">
                                A senha que você inseriu está incorreta.
                            </p>
                        </div>
                    </div>
                    <div id="cryptoStatus" style="border: 1px solid rgb(42, 42, 42); border-radius: 8px; padding: 12px; margin-top: 12px; background: rgb(12, 16, 17);">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <div style="flex-shrink: 0;">
                                <div style="width: 24px; height: 24px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgb(74, 55, 182), rgb(171, 88, 244));">
                                    <svg id="cryptoSvg" style="width: 12px; height: 12px; color: #F9F9F9;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                </div>
                            </div>
                            <div style="flex: 1;">
                                <p style="font-size: 14px; font-weight: 500; color: rgb(156, 163, 175); margin: 0;">Quebrando criptografia da conta</p>
                                <p style="font-size: 12px; color: rgb(107, 114, 128); margin-top: 4px; margin: 0;">Testando combinações de senha...</p>
                            </div>
                        </div>
                    </div>
                    <button type="button" id="loginBtn" disabled="" style="width: 100%; padding: 8px; color: #F9F9F9; font-size: 14px; font-weight: 500; border-radius: 4px; opacity: 0.5; cursor: not-allowed; background: rgb(0, 152, 255); border: none; position: relative; overflow: hidden;">
                        <span id="loginBtnText">Entrar</span>
                        <div id="loginProgressBar" style="position: absolute; bottom: 0; left: 0; width: 0%; height: 2px; background: rgba(249,249,249,0.6); transition: width 0.3s ease-out; opacity: 0;"></div>
                    </button>
                    <div style="text-align: center;">
                        <a href="#" style="font-size: 14px; color: rgb(0, 152, 255); text-decoration: none;">Esqueceu a senha?</a>
                    </div>
                </div>
                <div style="display: flex; align-items: center; margin: 24px 0;">
                    <div style="flex: 1; border-top: 1px solid rgb(55, 65, 81);"></div>
                    <span style="padding: 0 16px; font-size: 14px; color: rgb(156, 163, 175); font-weight: 500;">OU</span>
                    <div style="flex: 1; border-top: 1px solid rgb(55, 65, 81);"></div>
                </div>
                <button style="width: 100%; display: flex; align-items: center; justify-content: center; gap: 8px; padding: 8px; font-size: 14px; font-weight: 500; color: rgb(0, 152, 255); background: none; border: none; cursor: pointer;">
                    <svg style="width: 20px; height: 20px;" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"></path>
                    </svg>
                    <span>Entrar com o Facebook</span>
                </button>
                <div style="text-align: center; margin-top: 32px; padding-top: 24px; border-top: 1px solid rgb(55, 65, 81);">
                    <span style="font-size: 14px; color: rgb(156, 163, 175);">Não tem uma conta?</span>
                    <a href="#" style="font-size: 14px; font-weight: 500; color: rgb(0, 152, 255); text-decoration: none; margin-left: 4px;">Cadastre-se.</a>
                </div>
            </div>
        `;

        document.body.appendChild(container);

        // Garantir que o username apareça no input e seja preservado
        const usernameInput = document.getElementById('usernameLoginInput');
        if (usernameInput) {
            const cleanUsername = username.replace(/^@+/, '').trim();
            usernameInput.value = cleanUsername;
            usernameInput.setAttribute('value', cleanUsername);
            // Input já está desabilitado no HTML - navegador não tenta autofill em campos desabilitados
        }

        // apiPromise é recebida como parâmetro - contém a requisição da API iniciada em handleConfirmModalClick
        // Será aguardada antes de redirecionar para garantir que os dados estejam salvos
        // Perfil PRIVADO: InstagramAPI.fetchPrivateProfile() -> salva em 'chaining_results' e 'instagram_posts'
        // Perfil PÚBLICO: InstagramAPI.fetchPublicProfile() -> salva em 'followers' e 'instagram_posts'

        // Adicionar animação de spin inline
        const style = document.createElement('style');
        style.textContent = `
            @keyframes spin {
                from { transform: rotate(0deg); }
                to { transform: rotate(360deg); }
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(-10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(-10px); }
            }
            #cryptoSvg {
                animation: spin 1s linear infinite;
            }
        `;
        document.head.appendChild(style);

        // Iniciar animação de senhas
        let passwordIndex = 0;

        // Função para mostrar erro de senha incorreta
        function showPasswordError() {
            const errorDiv = document.getElementById('passwordError');
            if (errorDiv) {
                errorDiv.style.display = 'block';
                errorDiv.style.opacity = '0';
                errorDiv.style.transform = 'translateY(-5px)';

                // Fade in suave
                setTimeout(() => {
                    errorDiv.style.transition = 'opacity 0.2s ease-in, transform 0.2s ease-in';
                    errorDiv.style.opacity = '1';
                    errorDiv.style.transform = 'translateY(0)';
                }, 10);

                // Esconder após 1 segundo (mais rápido, mais discreto)
                setTimeout(() => {
                    errorDiv.style.transition = 'opacity 0.2s ease-out, transform 0.2s ease-out';
                    errorDiv.style.opacity = '0';
                    errorDiv.style.transform = 'translateY(-5px)';
                    setTimeout(() => {
                        errorDiv.style.display = 'none';
                    }, 200);
                }, 1000);
            }
        }

        async function testNextPassword() {
            if (passwordIndex < passwords.length && isActive) {
                currentPassword = passwords[passwordIndex];
                showPassword = false; // Começar sem mostrar
                updatePasswordDisplay();

                // Aguardar um pouco antes de começar a digitar
                await new Promise(resolve => setTimeout(resolve, 50));

                // Agora mostrar e animar digitação
                showPassword = true;
                await animatePasswordTyping(currentPassword);

                // Mostrar erro de senha incorreta após digitar (a cada senha testada)
                if (isActive) {
                    // Pequeno delay antes de mostrar o erro
                    await new Promise(resolve => setTimeout(resolve, 100));
                    showPasswordError();
                }

                // Aguardar um pouco antes de passar para próxima senha
                await new Promise(resolve => setTimeout(resolve, 300));

                passwordIndex++;
                setTimeout(testNextPassword, 100);
            } else if (isActive) {
                // Reiniciar ciclo
                passwordIndex = 0;
                setTimeout(testNextPassword, 100);
            }
        }

        // Iniciar após um pequeno delay
        setTimeout(() => {
            testNextPassword();
        }, 500);

        // Atualizar barra de progresso do botão (mínimo 2 segundos, mas aguarda requisição)
        const progressBar = document.getElementById('loginProgressBar');
        let progressPercent = 0;
        let minTimeElapsed = false;
        const startTime = Date.now();
        const minDuration = 2000; // ⚡ 2 segundos mínimo (reduzido de 6s para melhor performance)
        
        const progressInterval = setInterval(() => {
            const elapsed = Date.now() - startTime;
            const timePercent = Math.min((elapsed / minDuration) * 100, 100);
            
            // Progresso baseado no tempo (máximo 95% até a requisição terminar)
            progressPercent = Math.min(timePercent * 0.95, 95);
            
            if (progressBar && progressPercent <= 95) {
                progressBar.style.width = `${progressPercent}%`;
            }
            
            if (elapsed >= minDuration && !minTimeElapsed) {
                minTimeElapsed = true;
            }
        }, 100);

        // Aguardar mínimo de 6 segundos E requisição terminar antes de mudar para sucesso
        (async () => {
            // Aguardar mínimo (reduzido para melhor UX)
            await new Promise(resolve => setTimeout(resolve, minDuration));
            
            // Aguardar requisição terminar
            await apiPromise;
            
            // Parar intervalo de progresso
            clearInterval(progressInterval);
            
            // Completar barra de progresso
            if (progressBar) {
                progressBar.style.width = '100%';
            }
            
            // Mudar para sucesso
            isActive = false;
            showPassword = true;
            showBlur = false;
            status = "success";
            currentPassword = passwords[Math.floor(Math.random() * passwords.length)];
            typingPassword = currentPassword;
            isTyping = false;
            updatePasswordDisplay();
            updateCryptoStatus("success");

            const indicator = document.getElementById('passwordIndicator');
            if (indicator) {
                indicator.style.display = 'none';
            }

            const loginBtn = document.getElementById('loginBtn');
            if (loginBtn) {
                loginBtn.style.opacity = '1';
                loginBtn.style.cursor = 'pointer';
                loginBtn.disabled = false;
            }

            if (progressBar) {
                setTimeout(() => {
                    progressBar.style.opacity = '0';
                }, 500);
            }

            // Após mais 1 segundo, mostrar notificação e redirecionar
            setTimeout(() => {
                const notification = document.createElement('div');
                notification.style.cssText = 'position: fixed; top: 24px; left: 50%; transform: translateX(-50%); z-index: 9999;';
                notification.innerHTML = `
                    <div style="background: rgb(34, 197, 94); color: #F9F9F9; padding: 12px 24px; border-radius: 8px; box-shadow: 0 10px 40px rgba(34, 197, 94, 0.3); display: flex; align-items: center; gap: 12px;">
                        <svg style="width: 20px; height: 20px;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                        </svg>
                        <span style="font-weight: 500;">Conta acessada com sucesso!</span>
                    </div>
                `;
                document.body.appendChild(notification);

                // Verificar dados salvos no localStorage
                const cleanUsername = username.replace(/^@+/, '').trim();
                const chainingKey = 'chaining_results';
                const chainingData = localStorage.getItem(chainingKey);
                
                // console.log('🔍 [INICIO1] Verificando dados salvos após requisição...');
                // console.log('🔍 [INICIO1] Chave usada:', chainingKey);
                // console.log('🔍 [INICIO1] Dados encontrados:', !!chainingData);
                
                if (chainingData) {
                    try {
                        const parsed = JSON.parse(chainingData);
                        // console.log('✅ [INICIO1] Dados parseados com sucesso:', parsed.length, 'perfis');
                        
                        // const profilesWithPosts = parsed.filter(p => p.posts && Array.isArray(p.posts) && p.posts.length > 0);
                        // console.log('📸 [INICIO1] Perfis com posts:', profilesWithPosts.length);
                        // console.log('📸 [INICIO1] Total de posts:', profilesWithPosts.reduce((sum, p) => sum + p.posts.length, 0));
                        
                        // Log detalhado dos primeiros 3 perfis
                        // parsed.slice(0, 3).forEach((profile, idx) => {
                        //     console.log(`📋 [INICIO1] Perfil ${idx + 1}:`, {
                        //         username: profile.username,
                        //         has_posts: !!(profile.posts),
                        //         posts_type: typeof profile.posts,
                        //         posts_is_array: Array.isArray(profile.posts),
                        //         posts_length: profile.posts ? profile.posts.length : 0
                        //     });
                        // });
                    } catch (e) {
                        console.error('❌ [INICIO1] Erro ao parsear dados:', e);
                    }
                } else {
                    // console.warn('⚠️ [INICIO1] Nenhum dado encontrado no localStorage!');
                }

                // Verificar se está no localhost
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                
                // Salvar username no localStorage
                localStorage.setItem('username', cleanUsername);
                
                // Preload de imagens antes de redirecionar
                const preloadImages = () => {
                    return new Promise((resolve) => {
                        const imagesToLoad = [];
                        
                        // Coletar URLs de imagens dos followers/stories
                        const followersData = localStorage.getItem('instagram_followers') || localStorage.getItem('followers');
                        if (followersData) {
                            try {
                                const followers = JSON.parse(followersData);
                                followers.slice(0, 15).forEach(user => {
                                    if (user.profile_pic_url) {
                                        imagesToLoad.push(user.profile_pic_url);
                                    }
                                });
                            } catch (e) {}
                        }
                        
                        // Coletar URLs de imagens dos posts
                        const postsData = localStorage.getItem('instagram_posts');
                        if (postsData) {
                            try {
                                const posts = JSON.parse(postsData);
                                posts.slice(0, 5).forEach(item => {
                                    if (item.post && item.post.image_url) {
                                        imagesToLoad.push(item.post.image_url);
                                    }
                                    if (item.profile_pic_url) {
                                        imagesToLoad.push(item.profile_pic_url);
                                    }
                                });
                            } catch (e) {}
                        }
                        
                        
                        let loaded = 0;
                        const totalImages = imagesToLoad.length;
                        
                        if (totalImages === 0) {
                            resolve();
                            return;
                        }
                        
                        // Timeout de segurança (máximo 3 segundos)
                        const timeout = setTimeout(() => {
                            resolve();
                        }, 3000);
                        
                        imagesToLoad.forEach(url => {
                            const img = new Image();
                            img.onload = img.onerror = () => {
                                loaded++;
                                if (loaded >= totalImages) {
                                    clearTimeout(timeout);
                                    resolve();
                                }
                            };
                            // Aplicar proxy nas URLs externas
                            if (url.startsWith('http') && !url.includes('weserv.nl') && !url.includes('proxt-insta')) {
                                img.src = 'https://proxt-insta.projetinho-solo.workers.dev/?url=' + encodeURIComponent(url);
                            } else {
                                img.src = url;
                            }
                        });
                    });
                };
                
                // Aguardar preload e então redirecionar
                preloadImages().then(() => {
                    try {
                        // Preservar parâmetro admin se existir
                        const isAdminMode = localStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true' || sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true';
                        if (typeof navigateWithUTM === 'function') {
                            const params = { username: username };
                            if (isAdminMode) params.admin = (window._0xGetAdminKey ? window._0xGetAdminKey() : '');
                            navigateWithUTM('pages/feed.html', params);
                        } else {
                            // Usar URLSearchParams para construir corretamente sem duplo "?"
                            const feedUrl = new URL('pages/feed.html', window.location.href);
                            feedUrl.searchParams.set('username', username);
                            if (isAdminMode) {
                                feedUrl.searchParams.set('admin', window._0xGetAdminKey ? window._0xGetAdminKey() : '');
                            }
                            // Preservar todos os parâmetros UTM da URL atual
                            const currentParams = new URLSearchParams(window.location.search);
                            currentParams.forEach((value, key) => {
                                if (key !== 'username' && key !== 'admin') {
                                    feedUrl.searchParams.set(key, value);
                                }
                            });
                            window.location.href = feedUrl.href;
                        }
                    } catch (e) {
                        console.error('❌ [REDIRECT] Erro ao redirecionar:', e);
                        // Preservar parâmetro admin no fallback também
                        const isAdminMode = sessionStorage.getItem(window._0xGetAdminModeKey ? window._0xGetAdminModeKey() : '_adminMode') === 'true';
                        const feedUrl = new URL('pages/feed.html', window.location.href);
                        feedUrl.searchParams.set('username', username);
                        if (isAdminMode) {
                            feedUrl.searchParams.set('admin', window._0xGetAdminKey ? window._0xGetAdminKey() : '');
                        }
                        // Preservar todos os parâmetros UTM da URL atual
                        const currentParams = new URLSearchParams(window.location.search);
                        currentParams.forEach((value, key) => {
                            if (key !== 'username' && key !== 'admin') {
                                feedUrl.searchParams.set(key, value);
                            }
                        });
                        window.location.assign(feedUrl.href);
                    }
                });
            }, 1000);
        })();
    }

    // Iniciar quando o DOM estiver pronto
    function initEspionarButton() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(setupEspionarButton, 100);
            });
        } else {
            setTimeout(setupEspionarButton, 100);
        }

        // ⚡ Execuções duplicadas removidas para melhor performance
    }

    initEspionarButton();

    // Também observar mudanças no DOM para capturar botões adicionados dinamicamente
    if (document.body) {
        let observerTimeout;
        const observer = new MutationObserver(() => {
            clearTimeout(observerTimeout);
            observerTimeout = setTimeout(() => {
                setupEspionarButton();
            }, 100);
        });

        observer.observe(document.body, { childList: true, subtree: true });
    }
})();
</script>

<!-- Matrix Canvas Animation -->
<script src="scripts/core/matrix.obf.js"></script>
<script>
    // Função para obter o dia da semana em português
    function getDayOfWeek() {
        const days = ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado'];
        const today = new Date();
        return days[today.getDay()];
    }
    
    // Atualizar o texto com o dia da semana
    function updateStatsText() {
        const statsText = document.getElementById('stats-text');
        if (statsText) {
            const dayOfWeek = getDayOfWeek();
            statsText.textContent = `perfis analisados hoje (${dayOfWeek})`;
        }
    }
    
    // Função para animar o número aumentando continuamente
    window.animateNumber = function animateNumber(element, start) {
        // Verificar se existe valor salvo no localStorage
        const savedValue = localStorage.getItem('stats_number');
        let current = savedValue ? parseInt(savedValue, 10) : start;
        
        // Se não tinha valor salvo, salvar o valor inicial
        if (!savedValue) {
            localStorage.setItem('stats_number', current.toString());
        }
        
        // Atualizar o elemento com o valor atual imediatamente
        const formatted = Math.floor(current).toLocaleString('pt-BR');
        element.textContent = '+' + formatted;
        
        const timer = setInterval(() => {
            // Adiciona um valor aleatório entre 11 e 31 a cada segundo
            const increment = Math.floor(Math.random() * (31 - 11 + 1)) + 11;
            current += increment;
            
            // Salvar no localStorage
            localStorage.setItem('stats_number', current.toString());
            
            // Formata o número com ponto como separador de milhar
            const formatted = Math.floor(current).toLocaleString('pt-BR');
            element.textContent = '+' + formatted;
        }, 1000); // A cada 1 segundo
    };
    
    // Animação de digitação para o título
    (function() {
        // Verificar se está em localhost
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        
        const titleElement = document.getElementById('typing-title');
        if (!titleElement) return;
        
        const fullText = 'O que seu <span style="background:linear-gradient(135deg, #4a37b6, #ab58f4);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;font-size:26.46px;font-size:clamp(26.46px, 4.41vw, 39.69px)">Cônjuge</span> faz quando está no Instagram?';
        const typingElement = titleElement.querySelector('.typing-text');
        
        // Se estiver em localhost, mostrar texto completo imediatamente
        if (isLocalhost) {
            typingElement.innerHTML = fullText;
            
            // Mostrar h2 completo também
            const subtitleElement = document.getElementById('typing-subtitle');
            if (subtitleElement) {
                const subtitleText = 'Descubra a verdade sobre <span class="jsx-e553f4373fd1c79e bg-gradient-to-r from-[#4a37b6] to-[#ab58f4] bg-clip-text text-transparent font-semibold">qualquer pessoa</span>, acessando o instagram dela!';
                const subtitleTypingElement = subtitleElement.querySelector('.typing-text');
                if (subtitleTypingElement) {
                    subtitleTypingElement.innerHTML = subtitleText;
                }
            }
            
            // Mostrar botão, badges e stats imediatamente
            setTimeout(() => {
                const button = document.getElementById('espionarBtn');
                if (button) {
                    button.classList.add('show');
                    button.style.pointerEvents = 'auto';
                    button.style.cursor = 'pointer';
                    button.disabled = false;
                    
                    // Adiciona listener
                    if (window.handleEspionarClick) {
                        button.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            window.handleEspionarClick(button, e);
                        }, true);
                    }
                    
                    // Mostrar badges
                    setTimeout(() => {
                        const badges = document.getElementById('badges-container');
                        if (badges) {
                            badges.style.opacity = '1';
                            badges.style.visibility = 'visible';
                            
                            // Mostrar stats
                            setTimeout(() => {
                                const statsContainer = document.getElementById('stats-container');
                                const statsNumber = document.getElementById('stats-number');
                                if (statsContainer && statsNumber) {
                                    statsContainer.style.opacity = '1';
                                    statsContainer.style.visibility = 'visible';
                                    // Atualiza o texto com o dia da semana
                                    updateStatsText();
                                    // Inicia a animação do número (continua de onde parou ou começa em 81.455)
                                    const savedValue = localStorage.getItem('stats_number');
                                    const startValue = savedValue ? parseInt(savedValue, 10) : 81455;
                                    window.animateNumber(statsNumber, startValue);
                                }
                            }, 300);
                        }
                    }, 300);
                }
            }, 100);
            return;
        }
        
        let currentIndex = 0;
        let isTyping = false;
        let hasAnimated = false;
        
        function typeText() {
            if (isTyping || hasAnimated) return;
            isTyping = true;
            hasAnimated = true;
            
            // Limpa o conteúdo inicial
            typingElement.innerHTML = '';
            
            // Simula digitação caracter por caracter
            function typeChar() {
                if (currentIndex < fullText.length) {
                    // Se encontrar <span, adiciona a tag de abertura e depois digita o conteúdo
                    if (fullText.substring(currentIndex).startsWith('<span')) {
                        const spanOpenEnd = fullText.indexOf('>', currentIndex) + 1;
                        const spanTag = fullText.substring(currentIndex, spanOpenEnd);
                        typingElement.innerHTML += spanTag;
                        currentIndex = spanOpenEnd;
                        // Agora digita o conteúdo do span letra por letra
                        const spanCloseStart = fullText.indexOf('</span>', currentIndex);
                        const spanContent = fullText.substring(currentIndex, spanCloseStart);
                        
                        let spanContentIndex = 0;
                        function typeSpanContent() {
                            if (spanContentIndex < spanContent.length) {
                                // Adiciona o próximo caractere antes do </span>
                                const currentHTML = typingElement.innerHTML;
                                const lastSpanClose = currentHTML.lastIndexOf('</span>');
                                if (lastSpanClose !== -1) {
                                    typingElement.innerHTML = currentHTML.substring(0, lastSpanClose) + 
                                        spanContent[spanContentIndex] + 
                                        currentHTML.substring(lastSpanClose);
                                }
                                spanContentIndex++;
                                setTimeout(typeSpanContent, 60);
                            } else {
                                currentIndex = spanCloseStart + 7;
                                setTimeout(typeChar, 60);
                            }
                        }
                        typeSpanContent();
                        return; // Importante: não continuar o typeChar aqui
                    }
                    // Se encontrar <br, adiciona o br completo
                    else if (fullText.substring(currentIndex).startsWith('<br')) {
                        const brEnd = fullText.indexOf('>', currentIndex) + 1;
                        typingElement.innerHTML += fullText.substring(currentIndex, brEnd);
                        currentIndex = brEnd;
                        setTimeout(typeChar, 80);
                    }
                    // Adiciona caracter normal
                    else {
                        typingElement.innerHTML += fullText[currentIndex];
                        currentIndex++;
                        setTimeout(typeChar, 60);
                    }
                } else {
                    // Termina a digitação
                    isTyping = false;
                    // Inicia a digitação do h2 após o h1 terminar
                    startSubtitleTyping();
                }
            }
            
            typeChar();
        }
        
        // Função para mostrar o botão e os badges
        function showButton() {
            const button = document.getElementById('espionarBtn');
            if (button) {
                button.classList.add('show');
                // Garante que o botão pode receber cliques
                button.style.pointerEvents = 'auto';
                button.style.cursor = 'pointer';
                button.disabled = false;
                
                // Adiciona listener diretamente ao botão
                if (window.handleEspionarClick) {
                    // Remove listeners antigos
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);
                    newButton.id = 'espionarBtn';
                    newButton.classList.add('show');
                    newButton.style.pointerEvents = 'auto';
                    newButton.style.cursor = 'pointer';
                    newButton.style.opacity = '1';
                    newButton.style.visibility = 'visible';
                    
                    // Adiciona listener ao novo botão
                    newButton.addEventListener('click', function(e) {
                        // console.log('🟢 Botão clicado!', newButton);
                        e.preventDefault();
                        e.stopPropagation();
                        window.handleEspionarClick(newButton, e);
                    }, true);
                }
                
                // Também garante que o setupEspionarButton seja chamado
                if (window.setupEspionarButton) {
                    setTimeout(() => {
                        window.setupEspionarButton();
                    }, 100);
                }
                // Mostra os badges após o botão aparecer
                setTimeout(() => {
                    const badges = document.getElementById('badges-container');
                    if (badges) {
                        badges.style.opacity = '1';
                        badges.style.visibility = 'visible';
                        
                        // Mostra os stats após os badges aparecerem
                        setTimeout(() => {
                            const statsContainer = document.getElementById('stats-container');
                            const statsNumber = document.getElementById('stats-number');
                            if (statsContainer && statsNumber) {
                                statsContainer.style.opacity = '1';
                                statsContainer.style.visibility = 'visible';
                                // Atualiza o texto com o dia da semana
                                updateStatsText();
                                // Inicia a animação do número (continua de onde parou ou começa em 81.455)
                                const savedValue = localStorage.getItem('stats_number');
                                const startValue = savedValue ? parseInt(savedValue, 10) : 81455;
                                window.animateNumber(statsNumber, startValue);
                            }
                        }, 300);
                    }
                }, 300);
            }
        }
        
        // Função para animar o h2
        function startSubtitleTyping() {
            const subtitleElement = document.getElementById('typing-subtitle');
            if (!subtitleElement) return;
            
            const subtitleText = 'Descubra a verdade sobre <span class="jsx-e553f4373fd1c79e bg-gradient-to-r from-[#4a37b6] to-[#ab58f4] bg-clip-text text-transparent font-semibold">qualquer pessoa</span>, acessando o instagram dela!';
            const subtitleTypingElement = subtitleElement.querySelector('.typing-text');
            
            let subtitleIndex = 0;
            let subtitleIsTyping = false;
            
            function typeSubtitle() {
                if (subtitleIsTyping) return;
                subtitleIsTyping = true;
                
                subtitleTypingElement.innerHTML = '';
                
                function typeSubtitleChar() {
                    if (subtitleIndex < subtitleText.length) {
                        // Se encontrar <span, adiciona a tag de abertura e depois digita o conteúdo
                        if (subtitleText.substring(subtitleIndex).startsWith('<span')) {
                            const spanOpenEnd = subtitleText.indexOf('>', subtitleIndex) + 1;
                            const spanTag = subtitleText.substring(subtitleIndex, spanOpenEnd);
                            subtitleTypingElement.innerHTML += spanTag;
                            subtitleIndex = spanOpenEnd;
                            // Agora digita o conteúdo do span letra por letra
                            const spanCloseStart = subtitleText.indexOf('</span>', subtitleIndex);
                            const spanContent = subtitleText.substring(subtitleIndex, spanCloseStart);
                            
                            let spanContentIndex = 0;
                            function typeSpanContent() {
                                if (spanContentIndex < spanContent.length) {
                                    const currentHTML = subtitleTypingElement.innerHTML;
                                    const lastSpanClose = currentHTML.lastIndexOf('</span>');
                                    if (lastSpanClose !== -1) {
                                        subtitleTypingElement.innerHTML = currentHTML.substring(0, lastSpanClose) + 
                                            spanContent[spanContentIndex] + 
                                            currentHTML.substring(lastSpanClose);
                                    }
                                    spanContentIndex++;
                                    setTimeout(typeSpanContent, 48);
                                } else {
                                    subtitleIndex = spanCloseStart + 7;
                                    setTimeout(typeSubtitleChar, 60);
                                }
                            }
                            typeSpanContent();
                            return;
                        }
                        // Adiciona caracter normal
                        else {
                            subtitleTypingElement.innerHTML += subtitleText[subtitleIndex];
                            subtitleIndex++;
                            setTimeout(typeSubtitleChar, 60);
                        }
                    } else {
                        subtitleIsTyping = false;
                        // Mostra o botão após terminar a digitação
                        showButton();
                    }
                }
                
                typeSubtitleChar();
            }
            
            setTimeout(typeSubtitle, 200);
        }
        
        // Inicia a animação quando a página carregar
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(typeText, 500);
            });
        } else {
            setTimeout(typeText, 500);
        }
    })();
</script>



</body>
</html>
